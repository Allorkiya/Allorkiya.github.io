<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Game on Sum</title>
    <url>/2022-03-19-Game-on-Sum.html</url>
    <content><![CDATA[#
<center>
Game on Sum
</center>
<span id="more"></span>
<h2 id="题目描述">题目描述</h2>
<p>给定一个游戏，A最大化B最小化，B可以选择添加或减少，但是必须加<span class="math inline"><em>m</em></span>次，问游戏最终得分。</p>
<h2 id="范围">范围</h2>
<p><span class="math inline">1 ≤ <em>T</em> ≤ 10<sup>5</sup>, 1 ≤ <em>n</em> ≤ 10<sup>6</sup>, ∑<em>n</em> ≤ 10<sup>6</sup></span></p>
<h2 id="思路">思路</h2>
<p><span class="math inline"><em>f</em>[<em>n</em>][<em>m</em>]</span>表示当前还有<span class="math inline"><em>n</em></span>轮，<span class="math inline"><em>m</em></span>个加的情况的答案。</p>
<p>那么 <span class="math display">$$
f[i][j] = \frac{f[i - 1][j] + f[i - 1][j - 1]}{2}
$$</span></p>
<p>当两边同时乘<span class="math inline">2<sup><em>n</em></sup></span>的时候转化成： <span class="math display">2<sup><em>n</em></sup><em>f</em>[<em>n</em>][<em>m</em>] = 2<sup><em>n</em> − 1</sup><em>f</em>[<em>n</em> − 1][<em>m</em>] + 2<sup><em>n</em> − 1</sup><em>f</em>[<em>n</em> − 1][<em>m</em> − 1]</span>
令<span class="math inline"><em>g</em>[<em>n</em>][<em>m</em>] = 2<sup><em>n</em></sup><em>f</em>[<em>n</em>][<em>m</em>]</span></p>
<p>那么： <span class="math display"><em>g</em>[<em>n</em>][<em>m</em>] = <em>g</em>[<em>n</em> − 1][<em>m</em>] + <em>g</em>[<em>n</em> − 1][<em>m</em> − 1]</span>
那么只要找到一个<span class="math inline">(<em>i</em>, <em>i</em>)</span>点再乘上从<span class="math inline">(<em>i</em> + 1, <em>i</em>)</span>到<span class="math inline">(<em>n</em>, <em>m</em>)</span>的方案数：<span class="math inline"><em>C</em><sub><em>n</em> − <em>i</em> − 1</sub><sup><em>m</em> − <em>i</em></sup></span></p>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">ll fc[N];</span><br><span class="line">ll inv[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow_mod</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b) &#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * a  % mod;</span><br><span class="line">		a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	fc[<span class="number">0</span>] = fc[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N;i ++) &#123;</span><br><span class="line">		fc[i] = fc[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">		inv[i] = (mod - mod / i) % mod * inv[mod % i] % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; N;i ++) &#123;</span><br><span class="line">		inv[i] = inv[i - <span class="number">1</span>] * inv[i] % mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fc[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">init</span> ();</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T --) &#123;</span><br><span class="line">		<span class="type">int</span> n,m,k;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">		<span class="keyword">if</span>(n == m) &#123;</span><br><span class="line">			cout &lt;&lt;<span class="number">1ll</span> *  m * k % mod &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			ll ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i ++) &#123;</span><br><span class="line">				ans = (ans + <span class="number">1ll</span> * i * <span class="built_in">C</span>(n - i - <span class="number">1</span>,m - i) % mod * <span class="built_in">pow_mod</span>(<span class="built_in">pow_mod</span>(<span class="number">2</span>,n - i),mod - <span class="number">2</span>) % mod) % mod;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			cout &lt;&lt; ((ans + mod) * k) % mod &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>Combinatorial mathematics</category>
      </categories>
      <tags>
        <tag>Combinatorial mathematics</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 ICPC Nanjing-H Crystalfly</title>
    <url>/2022-03-01-2021-ICPC-Nanjing-H-Crystalfly.html</url>
    <content><![CDATA[#
<center>
2021ICPC南京H
</center>
<span id="more"></span>
<p>链接：<a href="https://vjudge.net/contest/482141#problem/A">传送门</a></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个<span class="math inline"><em>n</em></span>个节点的树，每个节点有权值<span class="math inline"><em>a</em><sub><em>i</em></sub></span>和消失时间<span class="math inline"><em>t</em><sub><em>i</em></sub></span>，若<span class="math inline"><em>t</em></span>时刻到达某个节点，其相邻节点会在<span class="math inline"><em>t</em> + <em>t</em><sub><em>i</em></sub></span>时刻消失，请问最大能获得多少权值？</p>
<h2 id="范围">范围：</h2>
<p><span class="math inline">∑<em>n</em> ≤ 10<sup>6</sup>, 1 ≤ <em>t</em><sub><em>i</em></sub> ≤ 3, 1 ≤ <em>n</em> ≤ 10<sup>5</sup>, 1 ≤ <em>a</em><sub><em>i</em></sub> ≤ 10<sup>9</sup></span></p>
<h2 id="思路">思路：</h2>
<p>这个题确实好有意思…</p>
<p>首先看过程，假设当前到了一个节点，那么它可以怎么往下走？</p>
<ol type="1">
<li>找一个点直接下去，之后回来再分别去别的子树</li>
<li>首先去一个别的节点，返回后再选一个点往下走，返回后再去别的子树</li>
</ol>
<p>1过程贪心的想一下就是选一个最大的点往下走，之后再回来走别的，只是相邻节点无了。</p>
<p>2过程贪心的想一下就是选择一个最大的<span class="math inline"><em>t</em><sub><em>i</em></sub> = 1/2</span>的点先下去，然后回来，再选一个<span class="math inline"><em>t</em><sub><em>i</em></sub> = 3</span>的节点下去，再回来走别的。</p>
<p>那么考虑设计状态： <span class="math display">$$
f_i 表示带a_i节点的子树的答案 \\
g_i 表示a_i节点已经消失的答案 \\
h_i 表示一个点被访问过之后回去父节点再访问这个节点的答案 \\
$$</span> 那么； <span class="math display">$$
f_u = a_u + g_u \\
h_u = a_u + \sum g_v \; u \; and \; v \; is \;adjacent
$$</span> 答案就为：<span class="math inline"><em>f</em><sub>1</sub></span></p>
<p>那么怎么算<span class="math inline"><em>g</em></span>函数？</p>
<p>考虑： <span class="math display">$$
g_u = \begin{cases}
max\{ f_v + \sum_{y \neq v} g(y)\} = max{a_v} + \sum g(v) \\
max\{ f(v) + h(y) + \sum_{p \neq v 且 p \neq y} g(p)\} = max(a_v) + h(y)
+ \sum_{p \neq y} g(p)
\end{cases}
$$</span> 取决于当前节点的子节点有没有<span class="math inline"><em>t</em><sub><em>i</em></sub> = 3</span></p>
<p>维护最大值、次大值可以线性维护。</p>
<p>PS：多组数据的清空数组不要用memset！</p>
<h2 id="代码">代码：</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">ll f[N];</span><br><span class="line">ll g[N];</span><br><span class="line">ll h[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> t[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mx1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mx2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mxa = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y : v[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//this</span></span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y : v[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        res += g[y];</span><br><span class="line">        mxa = <span class="built_in">max</span>(mxa,a[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//f = max(a_v) + \sum_g</span></span><br><span class="line">    <span class="comment">//h = a_x + </span></span><br><span class="line">    h[x] = a[x] + res;</span><br><span class="line">    g[x] = mxa + res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y : v[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(y == fa <span class="keyword">or</span> t[y] != <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[y] &gt; mx1) &#123;</span><br><span class="line">            mx2 = mx1;</span><br><span class="line">            mx1 = a[y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            mx2 = <span class="built_in">max</span>(mx2,a[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y : v[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t[y] == <span class="number">3</span> <span class="keyword">and</span> a[y] == mx1) &#123;</span><br><span class="line">            g[x] = <span class="built_in">max</span>(g[x],mx2 + h[y] - g[y] + res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            g[x] = <span class="built_in">max</span>(g[x],mx1 + h[y] + res - g[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x] = a[x] + g[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        v[i].<span class="built_in">clear</span>();</span><br><span class="line">        f[i] = <span class="number">0</span>;</span><br><span class="line">        g[i] = <span class="number">0</span>;</span><br><span class="line">        h[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i ++) &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        v[x].<span class="built_in">pb</span>(y);</span><br><span class="line">        v[y].<span class="built_in">pb</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>dp</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 Namomo-Camp 每日一题</title>
    <url>/2022-02-25-2022-Namomo-Camp-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98.html</url>
    <content><![CDATA[#
<center>
Namomo Camp
</center>
<span id="more"></span>
<h2 id="day1子串的最大差">Day1：子串的最大差</h2>
<p>链接：<a href="http://oj.daimayuan.top/course/10/problem/436">传送门</a></p>
<h3 id="题意简述">题意简述：</h3>
<p>求长度为<span class="math inline"><em>n</em></span>的序列所有连续子区间的最大值和最小值差的和。</p>
<h3 id="范围">范围:</h3>
<p><span class="math inline"><em>n</em> ≤ 5 × 10<sup>5</sup>, <em>a</em><sub><em>i</em></sub> ≤ 10<sup>8</sup></span></p>
<h3 id="解法">解法：</h3>
<p><span class="math display">$$
\sum\limits_{s \in sub_{seq}} Max - Min = \sum Max - \sum Min
$$</span></p>
<p>因此只需要算出每个点在多少个区间里有贡献，加和即可。</p>
<p>对于每个点<span class="math inline"><em>a</em><sub><em>i</em></sub></span>维护：</p>
<ul>
<li>区间最大值是<span class="math inline"><em>a</em><sub><em>i</em></sub></span>的区间最左端</li>
<li>区间最大值是<span class="math inline"><em>a</em><sub><em>i</em></sub></span>的区间最右端</li>
<li>包含的区间</li>
</ul>
<p>线段树维护即可（或者单调栈）。</p>
<h3 id="代码">代码：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> mxp[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> mnp[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> mx[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> mn[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ch = rt &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mx[ch] &gt; mx[ch + <span class="number">1</span>]) &#123;</span><br><span class="line">        mx[rt] = mx[ch];</span><br><span class="line">        mxp[rt] = mxp[ch];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mx[rt] = mx[ch + <span class="number">1</span>];</span><br><span class="line">        mxp[rt] = mxp[ch + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mn[ch] &lt; mn[ch + <span class="number">1</span>]) &#123;</span><br><span class="line">        mn[rt] = mn[ch];</span><br><span class="line">        mnp[rt] = mnp[ch];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mn[rt] = mn[ch + <span class="number">1</span>];</span><br><span class="line">        mnp[rt] = mnp[ch + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        mx[rt] = mn[rt] = a[l];</span><br><span class="line">        mxp[rt] = mnp[rt] = l;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ch = rt &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,ch);</span><br><span class="line">    <span class="built_in">build</span>(mid + <span class="number">1</span>,r,ch + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">update</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qry_mxp</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> ql,<span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l <span class="keyword">and</span> r &lt;= qr) &#123;</span><br><span class="line">        <span class="keyword">return</span> mxp[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = -INF;</span><br><span class="line">    <span class="type">int</span> ch = rt &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ansp;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">qry_mxp</span>(l,mid,ch,ql,qr);</span><br><span class="line">        <span class="keyword">if</span>(a[p] &gt; ans) ans = a[p],ansp = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">qry_mxp</span>(mid + <span class="number">1</span>,r,ch + <span class="number">1</span>,ql,qr);</span><br><span class="line">        <span class="keyword">if</span>(a[p] &gt; ans) ans = a[p],ansp = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qry_mnp</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt,<span class="type">int</span> ql,<span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= l <span class="keyword">and</span> r &lt;= qr) &#123;</span><br><span class="line">        <span class="keyword">return</span> mnp[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = INF;</span><br><span class="line">    <span class="type">int</span> ansp;</span><br><span class="line">    <span class="type">int</span> ch = rt &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ql &lt;= mid) &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">qry_mnp</span>(l,mid,ch,ql,qr);</span><br><span class="line">        <span class="keyword">if</span>(a[p] &lt; ans) ans = a[p],ansp = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(qr &gt; mid) &#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="built_in">qry_mnp</span>(mid + <span class="number">1</span>,r,ch + <span class="number">1</span>,ql,qr);</span><br><span class="line">        <span class="keyword">if</span>(a[p] &lt; ans) ans = a[p],ansp = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ansp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> a[l];</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ansp;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">1</span>) &#123;</span><br><span class="line">        ansp = <span class="built_in">qry_mxp</span>(<span class="number">1</span>,n,<span class="number">1</span>,l,r);</span><br><span class="line">    &#125;<span class="keyword">else</span> ansp = <span class="built_in">qry_mnp</span>(<span class="number">1</span>,n,<span class="number">1</span>,l,r);</span><br><span class="line">    ans = a[ansp] * <span class="number">1ll</span> * (ansp - l + <span class="number">1</span>) * (r - ansp + <span class="number">1</span>);</span><br><span class="line">    ans += <span class="built_in">query</span>(l,ansp - <span class="number">1</span>,op);</span><br><span class="line">    ans += <span class="built_in">query</span>(ansp + <span class="number">1</span>,r,op);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>,n,<span class="number">1</span>) - <span class="built_in">query</span>(<span class="number">1</span>,n,<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day2no-crossing">Day2：no crossing</h2>
<p>链接：<a href="http://oj.daimayuan.top/problem/437">传送门</a></p>
<h3 id="题意简述-1">题意简述</h3>
<p>给定<span class="math inline"><em>n</em></span>个节点，<span class="math inline"><em>m</em></span>条边的图，求恰好经过<span class="math inline"><em>k</em></span>个点的最短路径，并且每次选的边不能经过之前经过的节点。</p>
<h3 id="范围-1">范围：</h3>
<p><span class="math inline">1 ≤ <em>n</em>, <em>k</em> ≤ 100, 0 ≤ <em>m</em> ≤ 2000</span></p>
<h3 id="解法-1">解法：</h3>
<p><span class="math inline"><em>f</em>[<em>n</em><em>o</em><em>w</em>][<em>j</em>][<em>k</em>][0/1]</span>表示当前状态可以去的节点是<span class="math inline">[<em>j</em>, <em>k</em>]</span>，当前在左端点或右端点，类似于区间dp转移即可。</p>
<h3 id="代码-1">代码：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][N][N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="type">int</span> n,k,m;</span><br><span class="line"><span class="type">int</span> ans = INF;</span><br><span class="line"><span class="type">int</span> now;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="keyword">while</span>(m --) &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        d[u][v] = <span class="built_in">min</span>(d[u][v],w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f[<span class="number">0</span>],<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>][i][<span class="number">1</span>] = f[<span class="number">0</span>][i][n + <span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(-- k) &#123;</span><br><span class="line">        now ^= <span class="number">1</span>;<span class="built_in">memset</span>(f[now],<span class="number">0x3f</span>,<span class="keyword">sizeof</span> f[now]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">2</span>;j &lt;= n + <span class="number">1</span>; j ++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l = i + <span class="number">1</span>;l &lt; j;l ++) &#123;</span><br><span class="line">                    f[now][i][l][<span class="number">1</span>] = <span class="built_in">min</span>(f[now][i][l][<span class="number">1</span>],<span class="built_in">min</span>(f[!now][i][j][<span class="number">1</span>] + d[j][l],f[!now][i][j][<span class="number">0</span>] + d[i][l]));</span><br><span class="line">                    f[now][l][j][<span class="number">0</span>] = <span class="built_in">min</span>(f[now][l][j][<span class="number">0</span>],<span class="built_in">min</span>(f[!now][i][j][<span class="number">0</span>] + d[i][l],f[!now][i][j][<span class="number">1</span>] + d[j][l]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n + <span class="number">1</span>;i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= n + <span class="number">1</span>;j ++) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;#:&quot; &lt;&lt; f[now][i][j][0] &lt;&lt; &#x27; &#x27; &lt;&lt; f[now][i][j][1] &lt;&lt; endl;</span></span><br><span class="line">            ans = <span class="built_in">min</span> (ans,<span class="built_in">min</span>(f[now][i][j][<span class="number">0</span>],f[now][i][j][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; (ans &gt; (INF / <span class="number">2</span>) ? <span class="number">-1</span> : ans) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day3dis">Day3：Dis</h2>
<p>链接：<a href="http://oj.daimayuan.top/problem/451">传送门</a></p>
<h3 id="题意简述-2">题意简述：</h3>
<p>求树上两点间简单路径的点值异或和。</p>
<h3 id="范围-2">范围：</h3>
<p><span class="math inline"><em>n</em> ≤ 10<sup>5</sup></span></p>
<h3 id="解法-2">解法：</h3>
<p>啊我天，写的时候犯了病，开始把调试信息打上去了结果TLE，然后疯狂找错，最后重新敲了一下。。</p>
<p>就是一个很简单的记录树上前缀异或和，询问为： <span class="math display"><em>a</em><em>n</em><em>s</em> = <em>x</em><em>r</em><sub><em>x</em></sub> <em>x</em><em>o</em><em>r</em> <em>x</em><em>r</em><sub><em>y</em></sub> <em>x</em><em>o</em><em>r</em> <em>v</em><em>a</em><em>l</em>[<em>l</em><em>c</em><em>a</em>(<em>x</em>, <em>y</em>)]</span></p>
<h3 id="代码-2">代码：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">23</span>];</span><br><span class="line"><span class="type">int</span> xr[N];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dep[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dep[x] = dep[fa] + <span class="number">1</span>;</span><br><span class="line">    xr[x] ^= xr[fa];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y : v[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        f[y][<span class="number">0</span>] = x;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">20</span>;i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[f[x][i]] &gt;= dep[y]) x = f[x][i];</span><br><span class="line">        <span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">20</span>;i &gt;= <span class="number">0</span>;i --) &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][i] != f[y][i]) &#123;</span><br><span class="line">            x = f[x][i];</span><br><span class="line">            y = f[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        xr[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n;i ++) &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        v[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        v[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">22</span>;j ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">            f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m --) &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,xr[x] ^ xr[y] ^ a[<span class="built_in">lca</span>(x,y)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<h2 id="day4选数">Day4：选数</h2>
<p>链接：<a href="http://oj.daimayuan.top/problem/456">传送门</a></p>
<h3 id="题意简述-3">题意简述：</h3>
<p>给定<span class="math inline"><em>n</em></span>个数，从中选出若干个数，满足其和为<span class="math inline"><em>n</em></span>的倍数。</p>
<h3 id="范围-3">范围：</h3>
<p><span class="math inline"><em>n</em> ≤ 100000, 1 ≤ <em>a</em><sub><em>i</em></sub> ≤ 10<sup>9</sup></span></p>
<h3 id="解法-3">解法：</h3>
<p>很明显的一点是一个数膜<span class="math inline"><em>n</em></span>的范围是<span class="math inline">[0, <em>n</em> − 1]</span>这<span class="math inline"><em>n</em></span>种数，我们先把数组求个前缀和后膜<span class="math inline"><em>n</em></span>，现在考虑两种情况：</p>
<ol type="1">
<li>有两个值相同的情况</li>
<li>值为<span class="math inline">[0, <em>n</em> − 1]</span>每个值</li>
</ol>
<p>第2种情况很好搞，直接找0的地方输出就行。第1种情况就是找到两个相同值之后，输出它们中间的值，因为在膜<span class="math inline"><em>n</em></span>的剩余系下减法具有分配律。</p>
<h3 id="代码-3">代码：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        s[i] %= n;</span><br><span class="line">    &#125;</span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(s[i])) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i - mp[s[i]]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = mp[s[i]] + <span class="number">1</span>;j &lt;= i;j ++) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> mp[s[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day5序列操作">Day5：序列操作</h2>
<p>链接：<a href="http://oj.daimayuan.top/problem/452">传送门</a></p>
<h3 id="题目简述">题目简述：</h3>
<p>给定一个长度为<span class="math inline"><em>n</em></span>的序列，支持单点修改和整体将小于<span class="math inline"><em>x</em></span>的数字修改为<span class="math inline"><em>x</em></span>。</p>
<h3 id="范围-4">范围：</h3>
<p><span class="math inline"><em>n</em>, <em>q</em> ≤ 10<sup>6</sup>, <em>a</em><sub><em>i</em></sub> ≤ 10<sup>9</sup></span></p>
<h3 id="解法-4">解法：</h3>
<p>一开始本来想写线段树来着，但是看这个题是整体修改，就感觉应该是可以线性做，且<span class="math inline">1 ≤ <em>n</em> ≤ 10<sup>6</sup></span>。</p>
<p>然后我们考虑这个操作，在后面的1操作可以覆盖前面的1、2操作，后面的2操作也可以覆盖小的，那么不妨将操作倒过来，每个2操作记max，每个1操作和当前的max取max后打标记即可。</p>
<h3 id="代码-4">代码：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">&#125;t[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.id &gt; b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> mx;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            t[i].op = <span class="number">1</span>;</span><br><span class="line">            t[i].id = i;</span><br><span class="line">            t[i].x = x;</span><br><span class="line">            t[i].y = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;y);</span><br><span class="line">            t[i].op = <span class="number">2</span>;</span><br><span class="line">            t[i].id = i;</span><br><span class="line">            t[i].y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(t + <span class="number">1</span>,t + n + <span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i].op == <span class="number">2</span>) &#123;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx,t[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> x = t[i].x;</span><br><span class="line">            <span class="type">int</span> y = t[i].y;</span><br><span class="line">            <span class="keyword">if</span>(!f[x]) &#123;</span><br><span class="line">                f[x] = <span class="built_in">max</span>(y,mx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,<span class="built_in">max</span>(a[i],mx));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day6数数">Day6：数数</h2>
<h3 id="题意简述-4">题意简述：</h3>
<p>给定<span class="math inline"><em>n</em></span>长数组<span class="math inline"><em>A</em></span>，<span class="math inline"><em>q</em></span>次询问区间不大于某个数的个数。</p>
<h3 id="范围-5">范围：</h3>
<p><span class="math inline"><em>n</em> ≤ 10<sup>5</sup>, <em>q</em> ≤ 10<sup>5</sup>, <em>a</em><sub><em>i</em></sub> ≤ 10<sup>9</sup></span></p>
<h3 id="解法-5">解法：</h3>
<p>主席树求区间k大，离散化之后维护下标。</p>
<h3 id="代码-5">代码：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> lch,rch;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;t[N * <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> rt[N];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; v,ans;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),x) - v.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;rt)</span> </span>&#123;</span><br><span class="line">    rt = ++ idx;</span><br><span class="line">    t[rt].sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,t[rt].lch);</span><br><span class="line">    <span class="built_in">build</span>(mid + <span class="number">1</span>,r,t[rt].rch);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> &amp;rt,<span class="type">int</span> old,<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    rt = ++idx;</span><br><span class="line">    t[rt] = t[old];</span><br><span class="line">    t[rt].sum ++;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) <span class="built_in">insert</span>(l,mid,t[rt].lch,t[old].lch,p);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">insert</span>(mid + <span class="number">1</span>,r,t[rt].rch,t[old].rch,p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ql,<span class="type">int</span> qr,<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> t[qr].sum - t[ql].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(l,mid,t[ql].lch,t[qr].lch,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        res += t[t[qr].lch].sum - t[t[ql].lch].sum;</span><br><span class="line">        res += <span class="built_in">query</span>(mid + <span class="number">1</span>,r,t[ql].rch,t[qr].rch,p);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cas;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --) &#123;</span><br><span class="line">        ++cas;</span><br><span class="line">        idx = <span class="number">0</span>;v.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">            v.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">        v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>()),v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>,n,rt[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(<span class="number">1</span>,n,rt[i],rt[i - <span class="number">1</span>],<span class="built_in">get</span>(a[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(m --) &#123;</span><br><span class="line">            <span class="type">int</span> l,r,h;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;l,&amp;r,&amp;h);</span><br><span class="line">            <span class="type">int</span> k = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),h) - v.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span>(!k) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="built_in">query</span>(<span class="number">1</span>,n,rt[l - <span class="number">1</span>],rt[r],k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> k : ans) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day7minimum-or-spanning-tree">Day7：Minimum Or Spanning
Tree</h2>
<p>链接：<a href="http://oj.daimayuan.top/course/10/problem/454">传送门</a></p>
<h3 id="题意简述-5">题意简述：</h3>
<p>给定一个图，求最小生成树，权值定义为所有边权的按位或 。</p>
<h3 id="范围-6">范围：</h3>
<p><span class="math inline"><em>n</em>, <em>m</em> ≤ 4 × 10<sup>5</sup></span></p>
<h3 id="思路">思路：</h3>
<p>枚举二进制下30位，对于每一个1判断能否可行即可。</p>
<h3 id="代码-6">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w &lt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    a = <span class="built_in">find</span>(a);</span><br><span class="line">    b = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(a != b) &#123;</span><br><span class="line">        f[b] = a;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span>((w|x) == x) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">merge</span>(e[i].a,e[i].b)) cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        e[i].a = a;</span><br><span class="line">        e[i].b = b;</span><br><span class="line">        e[i].w = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e + <span class="number">1</span>,e + m + <span class="number">1</span>,cmp);</span><br><span class="line">    <span class="type">int</span> ans = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">29</span>;i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        ans ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check</span>(ans)) &#123;</span><br><span class="line">            ans ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day8摘桃子">Day8：摘桃子</h2>
<p>链接：<a href="http://oj.daimayuan.top/problem/466">传送门</a></p>
<h3 id="题意简述-6">题意简述</h3>
<p>给定<span class="math inline"><em>n</em></span>和<span class="math inline"><em>a</em><sub><em>i</em></sub></span>，求有多少种<span class="math inline"><em>l</em>, <em>r</em></span>满足<span class="math inline"><em>s</em><em>u</em><em>m</em><sub><em>r</em></sub> − <em>s</em><em>u</em><em>m</em><sub><em>l</em> − 1</sub> % <em>k</em> = <em>r</em> − <em>l</em> + 1</span>。</p>
<h3 id="范围-7">范围</h3>
<p><span class="math inline"><em>n</em> ≤ 2 × 10<sup>5</sup>, 1 ≤ <em>k</em> ≤ 10<sup>9</sup>, 1 ≤ <em>a</em><sub><em>i</em></sub> ≤ 10<sup>9</sup></span></p>
<h3 id="解法-6">解法：</h3>
<p>将式子变换一下： <span class="math display"><em>s</em><em>u</em><em>m</em><sub><em>r</em></sub> − <em>r</em> = <em>s</em><em>u</em><em>m</em><sub><em>l</em> − 1</sub> − (<em>l</em> − 1) (<em>m</em><em>o</em><em>d</em> <em>k</em>)</span>
这样的话，，处理出所有的<span class="math inline"><em>s</em><em>u</em><em>m</em><sub><em>i</em></sub> − <em>i</em></span>，之后对于每个<span class="math inline"><em>i</em></span>找出有多少个<span class="math inline"><em>l</em></span>满足即可。</p>
<h3 id="代码-7">代码：</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line">map &lt;ll,<span class="type">int</span>&gt; f;</span><br><span class="line">ll s[N];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        s[i] = (s[i - <span class="number">1</span>] + x - <span class="number">1</span>) % k;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="number">0</span>) ans ++;</span><br><span class="line">        <span class="keyword">if</span>(++ r - l + <span class="number">1</span> &gt; k) f[s[l ++]] --;</span><br><span class="line">        ans += f[s[i]];</span><br><span class="line">        f[s[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day9路径计数2">Day9：路径计数2</h2>
<p>链接：<a href="http://oj.daimayuan.top/problem/467">传送门</a></p>
<h3 id="题意简述-7">题意简述</h3>
<p>给定一个<span class="math inline"><em>n</em> × <em>n</em></span>的网格，有<span class="math inline"><em>m</em></span>个障碍，求从<span class="math inline">(1, 1)− &gt; (<em>n</em>, <em>n</em>)</span>的方案数是多少？</p>
<h3 id="范围-8">范围</h3>
<p><span class="math inline"><em>n</em> ≤ 10<sup>6</sup>, <em>m</em> ≤ 3000</span></p>
<h3 id="思路-1">思路</h3>
<p>从<span class="math inline"><em>m</em> ≤ 3000</span>下手想，考虑从左上角到右下点的所有路径为：
<span class="math display"><em>C</em><sub><em>n</em> + <em>m</em> − 2, <em>n</em> − 1</sub></span>
那么，若中间有一个点<span class="math inline">(<em>x</em>, <em>y</em>)</span>障碍，那么路径条数为总路径减不合法路径
<span class="math display"><em>C</em><sub><em>x</em> + <em>y</em> − 2, <em>x</em> − 1</sub> * <em>C</em>(<em>n</em> − <em>x</em> + <em>n</em> − <em>y</em>, <em>n</em> − <em>x</em>)</span>
记到第<span class="math inline"><em>i</em></span>个点的合法路径数为<span class="math inline"><em>f</em><sub><em>i</em></sub></span>，那么 <span class="math display">$$
f_i = all - \sum_{j = 1}^{m}f_j \times now
$$</span> 最后<span class="math inline"><em>f</em><sub><em>m</em></sub></span>为答案。</p>
<p>注意，我们可以将<span class="math inline">(<em>n</em>, <em>m</em>)</span>记为一个障碍点。</p>
<h3 id="代码-8">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">int</span> fc[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> ifc[M &lt;&lt; <span class="number">1</span>];</span><br><span class="line">ll f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow_mod</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * a % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    fc[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; <span class="number">2</span> * M; i ++) &#123;</span><br><span class="line">        fc[i] = <span class="number">1ll</span> * fc[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ifc[<span class="number">2</span> * M - <span class="number">1</span>] = <span class="built_in">pow_mod</span>(fc[<span class="number">2</span> * M - <span class="number">1</span>],mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span> * M - <span class="number">1</span>;i &gt;= <span class="number">1</span>;i --) &#123;</span><br><span class="line">        ifc[i - <span class="number">1</span>] = <span class="number">1ll</span> * ifc[i] * i % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span> <span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1ll</span> * fc[n] % mod * ifc[m] % mod * ifc[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">&#125;d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x + a.y &lt; b.x + b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        d[i].x = x;</span><br><span class="line">        d[i].y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    m ++;</span><br><span class="line">    d[m].x = n;</span><br><span class="line">    d[m].y = n;</span><br><span class="line">    <span class="built_in">sort</span>(d + <span class="number">1</span>,d + m + <span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">C</span>(d[i].x + d[i].y - <span class="number">2</span>,d[i].x - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != j <span class="keyword">and</span> d[j].x &lt;= d[i].x <span class="keyword">and</span> d[j].y &lt;= d[i].y) &#123;</span><br><span class="line">                res = ((res - ((<span class="number">1ll</span> * f[j] * <span class="built_in">C</span>(d[i].x - d[j].x + d[i].y - d[j].y,d[i].x - d[j].x) % mod)) % mod) + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i] = res;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[m] % mod &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day10函数求和">Day10：函数求和</h2>
<p>链接：<a href="http://oj.daimayuan.top/course/10/problem/468">传送门</a></p>
<h3 id="题意简述-8">题意简述</h3>
<p>求<span class="math inline">$\sum_{i =
0}^{2^k-1}f(i)$</span>，其中<span class="math inline"><em>f</em><sub><em>i</em></sub></span>表示满足<span class="math inline"><em>a</em><sub><em>i</em></sub>&amp;<em>x</em> ≠ <em>a</em><sub><em>i</em></sub></span>的最小的<span class="math inline"><em>i</em></span>，若不存在则<span class="math inline"><em>f</em><sub><em>i</em></sub> = 0</span>。</p>
<h3 id="范围-9">范围</h3>
<p><span class="math inline"><em>n</em> ≤ 100, <em>k</em> ≤ 60</span></p>
<h3 id="思路-2">思路</h3>
<p>其实可以直接<span class="math inline"><em>O</em>(<em>n</em><em>k</em>)</span>做，考虑<span class="math inline"><em>a</em><sub><em>i</em></sub>&amp;<em>x</em> = <em>a</em><sub><em>i</em></sub></span>有多少种情况？</p>
<ol type="1">
<li>对于某一位的1，那么另一个数也必须为1</li>
<li>对于某一位的0，另一个数的这一位可以为任何数。</li>
</ol>
<p>组合计数即可。</p>
<h3 id="代码-9">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow_mod</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * a % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> q = <span class="number">0</span>,f = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)f = - <span class="number">1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        q = q * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    bitset &lt;64&gt; bt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        bitset &lt;64&gt; <span class="built_in">a</span>(<span class="built_in">read</span>());</span><br><span class="line">        <span class="type">int</span> c1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> c0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; k; j ++) &#123;</span><br><span class="line">            c1 += ((!bt[j]) &amp;&amp; a[j]);</span><br><span class="line">            c0 += (!(bt[j] || a[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c1) &#123;</span><br><span class="line">            ans = (ans + <span class="number">1ll</span> * (<span class="number">1ll</span> * i * (<span class="built_in">pow_mod</span>(<span class="number">2</span>,c1) - <span class="number">1</span>) % mod) % mod * (<span class="built_in">pow_mod</span>(<span class="number">2</span>,c0) % mod) % mod + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        bt |= a;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day11xor-inverse">Day11：XOR Inverse</h2>
<p>链接：<a href="http://oj.daimayuan.top/problem/497">传送门</a></p>
<h3 id="题意简述-9">题意简述</h3>
<p>给定一个长度为<span class="math inline"><em>n</em></span>的数组<span class="math inline"><em>a</em></span>，你需要求一个中最小的非负整数<span class="math inline"><em>x</em></span>，满足<span class="math inline"><em>b</em><sub><em>i</em></sub> = <em>a</em><sub><em>i</em></sub> <em>x</em><em>o</em><em>r</em> <em>x</em></span>且<span class="math inline"><em>b</em></span>数组逆序对最小。</p>
<h3 id="范围-10">范围</h3>
<p><span class="math inline">1 ≤ <em>n</em> ≤ 3 × 10<sup>5</sup>, 0 ≤ <em>a</em><sub><em>i</em></sub> ≤ 10<sup>9</sup></span></p>
<h3 id="思路-3">思路</h3>
<p>一看这种就像是字典树…</p>
<p>将所有数字都插入进去之后，对于一个节点来说，如果只有一个分支，那么无逆序对。如果有两个，那么枚举0那一侧的，如果下标比1侧的大，那么就有逆序对，递归处理即可。</p>
<h3 id="代码-10">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">int</span> ch[N * <span class="number">30</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line">ll cnt[<span class="number">31</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; f[N * <span class="number">31</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i --) &#123;</span><br><span class="line">        <span class="type">int</span> t = (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ch[pos][t]) ch[pos][t] = ++idx;</span><br><span class="line">        pos = ch[pos][t];</span><br><span class="line">        f[pos].<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> x,<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> lch = ch[p][<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> rch = ch[p][<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!lch <span class="keyword">and</span> !rch) <span class="keyword">return</span>;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y : f[lch]) &#123;</span><br><span class="line">        <span class="keyword">while</span>(id &lt; f[rch].<span class="built_in">size</span>() <span class="keyword">and</span> y &gt; f[rch][id]) ++ id;</span><br><span class="line">        sum += id;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[x][<span class="number">0</span>] += sum;</span><br><span class="line">    cnt[x][<span class="number">1</span>] += <span class="number">1ll</span> * f[lch].<span class="built_in">size</span>() * f[rch].<span class="built_in">size</span>() - sum;</span><br><span class="line">    <span class="keyword">if</span>(lch) <span class="built_in">dfs</span>(x - <span class="number">1</span>,lch);</span><br><span class="line">    <span class="keyword">if</span>(rch) <span class="built_in">dfs</span>(x - <span class="number">1</span>,rch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="built_in">insert</span>(x,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">30</span>,<span class="number">0</span>);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i][<span class="number">0</span>] &lt;= cnt[i][<span class="number">1</span>]) ans += cnt[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += cnt[i][<span class="number">1</span>];</span><br><span class="line">            v ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day12closest-equals">Day12：Closest Equals</h2>
<p>链接：<a href="http://oj.daimayuan.top/problem/469">传送门</a></p>
<h3 id="题意简述-10">题意简述</h3>
<p>给定一个序列，询问区间中两个相同的值最近的距离是多少？</p>
<h3 id="范围-11">范围</h3>
<p><span class="math inline"><em>n</em> ≤ 5 × 10<sup>5</sup>, <em>a</em><sub><em>i</em></sub> ≤ 10<sup>9</sup></span></p>
<h3 id="思路-4">思路</h3>
<p>首先离散化，将询问按照右端点排序。</p>
<p>记一个<span class="math inline"><em>p</em><em>r</em><em>e</em><sub><em>i</em></sub></span>数组表示<span class="math inline"><em>a</em><sub><em>i</em></sub></span>的上一个出现位置，查询到<span class="math inline"><em>a</em><sub><em>i</em></sub></span>时如果<span class="math inline"><em>p</em><em>r</em><em>e</em><sub><em>i</em></sub></span>有数字，那么改为<span class="math inline"><em>i</em> − <em>p</em><em>r</em><em>e</em><sub><em>i</em></sub></span>表示距离，之后就是区间查询最小值。</p>
<h3 id="代码-11">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_q</span> &#123;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line">vector &lt;_q&gt; q[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> mn = INF;</span><br><span class="line">&#125;t[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ch = rt &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    t[rt].mn = <span class="built_in">min</span>(t[ch].mn,t[ch + <span class="number">1</span>].mn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    t[rt].l = l;</span><br><span class="line">    t[rt].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l,mid,rt &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(mid + <span class="number">1</span>,r,rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">update</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span> <span class="params">(<span class="type">int</span> rt,<span class="type">int</span> p,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t[rt].l == t[rt].r) &#123;</span><br><span class="line">        t[rt].mn = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (t[rt].l + t[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ch = rt &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) &#123;</span><br><span class="line">        <span class="built_in">modify</span>(ch,p,v);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">modify</span>(ch + <span class="number">1</span>,p,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> rt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span>(t[rt].l == l <span class="keyword">and</span> t[rt].r == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> t[rt].mn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (t[rt].l + t[rt].r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = INF;</span><br><span class="line">    <span class="type">int</span> ch = rt &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans,<span class="built_in">query</span>(l,r,ch));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid) &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans,<span class="built_in">query</span>(l,r,ch + <span class="number">1</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans,<span class="built_in">min</span>(<span class="built_in">query</span>(l,mid,ch),<span class="built_in">query</span>(mid + <span class="number">1</span>,r,ch + <span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> b[N];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>,b + n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> nn = <span class="built_in">unique</span>(b + <span class="number">1</span>,b + n + <span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123;</span><br><span class="line">        a[i] = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>,b + nn + <span class="number">1</span>,a[i]) - b;</span><br><span class="line">        pre[i] = p[a[i]];</span><br><span class="line">        p[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        q[r].<span class="built_in">push_back</span>((_q)&#123;l,i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[i]) &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>,pre[i],i - pre[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; q[i].<span class="built_in">size</span>();j ++) &#123;</span><br><span class="line">            ans[q[i][j].id] = <span class="built_in">query</span>(q[i][j].l,i,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i] &gt; (<span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day13ccpc-harbin-2021-g-damaged-bicycle">Day13：CCPC Harbin 2021
G, Damaged Bicycle</h2>
<p>链接：<a href="http://oj.daimayuan.top/problem/380">传送门</a></p>
<h3 id="题意简述-11">题意简述</h3>
<p>校园可以被看成<span class="math inline"><em>n</em></span>个点，<span class="math inline"><em>m</em></span>条无向边的图，其中第i条边的长度是<span class="math inline"><em>w</em><sub><em>i</em></sub></span>。你的宿舍在1号点，教学楼在n号点，你想从宿舍去教学楼。你的走路速度是每秒t，骑车速度是每秒r。根据共享单车app，校园内一共有k个停车点。第i个停车点在ai点，但是有<span class="math inline">${p_i} \over
{100}$</span>的概率，车可能是坏的。但是你只有到达<span class="math inline"><em>a</em><sub><em>i</em></sub></span>点，然后扫描二维码之后才能知道第i辆车是不是好的。如果车是好的，那就可以骑到终点。</p>
<p>问你最优策略下，你最小的到达终点的期望时间是多少。如果到达不了n号点，输出<code>-1</code>。</p>
<h3 id="范围-12">范围</h3>
<p><span class="math inline"><em>n</em>, <em>m</em> ≤ 10<sup>5</sup>, <em>k</em> ≤ 18</span></p>
<h3 id="思路-5">思路</h3>
<p>设<span class="math inline"><em>f</em>[<em>S</em>][<em>u</em>]</span>表示使用过的单车状态为<span class="math inline"><em>S</em></span>，当前在点<span class="math inline"><em>u</em></span>，到达终点的期望时间。</p>
<p>根据题意转移即可，最短路径使用迪杰斯特拉，记搜即可。</p>
<h3 id="代码-12">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = INT_MAX;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> to;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (node a,node b)&#123;<span class="keyword">return</span> a.w&gt;b.w;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &gt; (node a,node b)&#123;<span class="keyword">return</span> a.w&lt;b.w;&#125;</span><br><span class="line">vector &lt;node&gt; e[N];</span><br><span class="line">priority_queue &lt;node&gt; q;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">30</span>][N];</span><br><span class="line"><span class="type">double</span> f[N][<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">30</span>][N];</span><br><span class="line"><span class="type">int</span> t,r,n,m,k;</span><br><span class="line"><span class="type">double</span> p[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij</span> <span class="params">(<span class="type">int</span> p,<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; p &lt;&lt; &#x27; &#x27; &lt;&lt; u &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        dis[p][i] = INF;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;u,<span class="number">0</span>&#125;);</span><br><span class="line">    dis[p][u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node u = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[p][u.to]) <span class="keyword">continue</span>;</span><br><span class="line">        dis[p][u.to] = u.w;</span><br><span class="line">        vis[p][u.to] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y : e[u.to]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[p][y.to] &gt; dis[p][u.to] + y.w) &#123;</span><br><span class="line">                dis[p][y.to] = dis[p][u.to] + y.w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;y.to,dis[p][y.to]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> st,<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[st][u]) <span class="keyword">return</span> f[st][u];</span><br><span class="line">    <span class="type">double</span> tmp = <span class="number">1.0</span> * p[u] * dis[u][n] / t + (<span class="number">1</span> - p[u]) * dis[u][n] / r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(st &amp; (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">        tmp = <span class="built_in">min</span>(tmp,<span class="number">1.0</span> * (<span class="number">1</span> - p[u]) * dis[u][n] / r + p[u] * (<span class="number">1.0</span> * dis[u][a[i]] / t + <span class="built_in">dfs</span>(st | (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)),i)));   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[st][u] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; t &gt;&gt; r &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        e[u].<span class="built_in">pb</span>(&#123;v,w&#125;);</span><br><span class="line">        e[v].<span class="built_in">pb</span>(&#123;u,w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="type">int</span> tt;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;tt);</span><br><span class="line">        p[i] = <span class="number">1.0</span> * tt / <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">dij</span>(i,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dij</span>(<span class="number">19</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dij</span>(<span class="number">20</span>,n);</span><br><span class="line">    p[<span class="number">19</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dis[<span class="number">19</span>][n] == INF) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">19</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf\n&quot;</span>,f[<span class="number">0</span>][<span class="number">19</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day14拆方块">Day14：拆方块</h2>
<p>链接：<a href="http://oj.daimayuan.top/course/10/problem/501">传送门</a> ###
题目描述
给定每个地方的方块，每次清楚只能清除“边界方块”，求最少多少次操作所有方块会消失？
### 范围 <span class="math inline"><em>n</em> ≤ 10<sup>5</sup>, <em>a</em><sub><em>i</em></sub> ≤ 10<sup>9</sup></span>
### 思路
我们不妨把每次的消失看成一个有方向的消失，比如说每次消失一个轮廓线，那这样的话维护一个从左到右的最少消失次数和从右到左的最少消失次数，然后枚举每个点统计答案即可。
### 代码 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l[N];</span><br><span class="line"><span class="type">int</span> r[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	l[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">		l[i] = <span class="built_in">min</span>(l[i - <span class="number">1</span>] + <span class="number">1</span>,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	r[n] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">1</span>; i --) &#123;</span><br><span class="line">		r[i] = <span class="built_in">min</span>(r[i + <span class="number">1</span>] + <span class="number">1</span>,a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) &#123;</span><br><span class="line">		ans = <span class="built_in">max</span>(ans,<span class="built_in">min</span>(l[i],r[i]));</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## Day15：连续子序列 链接：<a href="http://oj.daimayuan.top/problem/504">传送门</a> ### 题目描述
给定一个长度为<span class="math inline"><em>n</em></span>的序列，找到一组指标集<span class="math inline"><em>p</em><sub><em>m</em></sub></span>使得<span class="math inline"><em>a</em><sub><em>i</em></sub> − <em>a</em><sub><em>i</em> − 1</sub> = 1, <em>i</em> ∈ <em>p</em></span>，求出最大的<span class="math inline"><em>m</em></span>和最小答案的子序列。 ### 范围 <span class="math inline"><em>n</em> ≤ 200000, 1 ≤ <em>a</em><sub><em>i</em></sub> ≤ 10<sup>9</sup></span>
### 思路 维护值域，对于字典序最小可以通过维护起始数值得到。 ### 代码
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],m,m_a;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;pre_a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="type">int</span> a; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">        <span class="type">int</span> now_m=pre_a[a<span class="number">-1</span>]<span class="number">+1</span>,now_m_a=a-now_m<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>(now_m&gt;m || (now_m==m &amp;&amp; now_m_a&lt;m_a))&#123;</span><br><span class="line">            m=now_m;</span><br><span class="line">            m_a=now_m_a;</span><br><span class="line">        &#125;</span><br><span class="line">        pre_a[a]=now_m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,m_a+i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## Day16：工作安排 链接：<a href="http://oj.daimayuan.top/problem/503">传送门</a> ### 题目描述 见题
### 范围 <span class="math inline"><em>n</em> ≤ 10<sup>5</sup>, <em>d</em><sub><em>i</em></sub>, <em>p</em><sub><em>i</em></sub> ≤ 10<sup>9</sup></span>
### 思路
优先队列题，先按照截止时间进行工作，但是会发现可能有价值高却不能做的，这个时候进行撤销操作即可。
### 代码 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> d first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> p second</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="type">int</span> n,cnt;</span><br><span class="line">PII s[N];</span><br><span class="line">LL ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;s[i].d,&amp;s[i].p);</span><br><span class="line">	<span class="built_in">sort</span>(s<span class="number">+1</span>,s<span class="number">+1</span>+n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(cnt&gt;=s[i].d)&#123;</span><br><span class="line">		<span class="keyword">if</span>(q.<span class="built_in">empty</span>() || (-q.<span class="built_in">top</span>())&gt;s[i].p) <span class="keyword">continue</span>;</span><br><span class="line">			ans+=q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>(); --cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		q.<span class="built_in">push</span>(-s[i].p); ++cnt; ans+=s[i].p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## Day17：三角果计数 链接：<a href="http://oj.daimayuan.top/problem/505">传送门</a></p>
<h3 id="题目描述">题目描述</h3>
<p>给定一个<span class="math inline"><em>n</em></span>个节点的树，求有多少个无序三元组<span class="math inline">(<em>a</em>, <em>b</em>, <em>c</em>)</span>满足两两之间的最短路径距离构成三角形？
### 范围 <span class="math inline"><em>n</em> ≤ 10<sup>5</sup>, <em>w</em> ≤ 10<sup>5</sup></span></p>
<h3 id="思路-6">思路</h3>
<p>会有两种形式的答案：</p>
<ol type="1">
<li>三个节点都在<span class="math inline"><em>x</em></span>的子节点</li>
<li>有两个是子节点，一个是父节点</li>
</ol>
<p>那么设<span class="math inline"><em>f</em><sub><em>x</em>, <em>j</em></sub></span>表示从<span class="math inline"><em>x</em></span>为根的子树中选择几个子树中的节点的方案数，那么：
<span class="math display"><em>f</em>[<em>x</em>][<em>j</em>]+ = <em>f</em>[<em>x</em>][<em>j</em> − 1] * <em>s</em><em>i</em><em>z</em>[<em>v</em>]</span></p>
<p>答案就是：<span class="math inline">∑<sub><em>x</em></sub><em>f</em>[<em>x</em>][3] + <em>f</em>[<em>x</em>][2] * (<em>n</em> − <em>s</em><em>i</em><em>z</em>[<em>x</em>])</span></p>
<h3 id="代码-13">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line">ll f[N][<span class="number">4</span>];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[x] = f[x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; e[x].<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">        <span class="type">int</span> y = e[x][i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">3</span>;j &gt;= <span class="number">1</span>; j --) &#123;</span><br><span class="line">            f[x][j] += f[x][j - <span class="number">1</span>] * siz[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += f[x][<span class="number">3</span>] + f[x][<span class="number">2</span>] * (n - siz[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        e[u].<span class="built_in">pb</span>(v);</span><br><span class="line">        e[v].<span class="built_in">pb</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day18整齐的数组2">Day18：整齐的数组2</h2>
<p>链接：<a href="http://oj.daimayuan.top/course/10/problem/555">传送门</a> ###
题目描述 给定一个长度为<span class="math inline"><em>n</em></span>的数组<span class="math inline"><em>A</em></span>，每次选一个数字减<span class="math inline"><em>k</em></span>，求进行若干次操作之后数组<span class="math inline"><em>A</em></span>中至少有一半变成相同的最大的<span class="math inline"><em>k</em></span>，若<span class="math inline"><em>k</em></span>可以无穷大，输出<code>-1</code>。
### 范围 <span class="math inline">1 ≤ <em>T</em> ≤ 40, 4 ≤ <em>n</em> ≤ 40, −10<sup>6</sup> ≤ <em>a</em><sub><em>i</em></sub> ≤ 10<sup>6</sup></span>
### 思路 无穷大：一开始的数组中某个数的出现次数就已经大于<span class="math inline">$\frac{n}{2}$</span>。</p>
<p>根据剩余系下统计计算即可。</p>
<h3 id="代码-14">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) cin &gt;&gt; a[i],a[i] += <span class="number">1000000</span>;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>,a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        ++cnt[a[i]];</span><br><span class="line">        <span class="keyword">if</span>(cnt[a[i]] &gt;= n / <span class="number">2</span>) &#123;</span><br><span class="line">            ans = INT_MAX;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == INT_MAX) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) cnt[a[i]] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) cnt[a[i]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = a[n];k &gt;= <span class="number">1</span>;k --) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">                ++cnt[a[i] % k];</span><br><span class="line">                <span class="keyword">if</span>(cnt[a[i] % k] &gt;= n / <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n; j ++) cnt[a[j] % k] = <span class="number">0</span>;</span><br><span class="line">                        cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) cnt[a[i] % k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day19三进制循环">Day19：三进制循环</h2>
<p>链接：<a href="http://oj.daimayuan.top/course/10/problem/556">传送门</a> ###
题目描述 给定一个树，点权为0,1,2，求一条最长的树上路径满足<span class="math inline"><em>G</em><sub><em>i</em></sub> = <em>G</em><sub><em>i</em> − 1</sub> + 1 <em>m</em><em>o</em><em>d</em> 3</span>
### 范围 <span class="math inline"><em>n</em> ≤ 500000</span> ### 思路
路径分为过某点的和不过某点的，那么记<span class="math inline"><em>f</em><sub><em>x</em></sub></span>表示从某节点出发到<span class="math inline"><em>x</em></span>节点的最长路径，<span class="math inline"><em>g</em><sub><em>x</em></sub></span>表示从<span class="math inline"><em>x</em></span>节点出发的最长路径，那么每次答案拼凑起来即可。
### 代码 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> g[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>] = f[x][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;y : v[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        <span class="keyword">if</span>(g[x] == (g[y] + <span class="number">1</span>) % <span class="number">3</span>) f[x][<span class="number">0</span>] = <span class="built_in">max</span>(f[x][<span class="number">0</span>],f[y][<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(g[y] == (g[x] + <span class="number">1</span>) % <span class="number">3</span>) f[x][<span class="number">1</span>] = <span class="built_in">max</span>(f[x][<span class="number">1</span>],f[y][<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans,f[x][<span class="number">0</span>] + f[x][<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        v[x].<span class="built_in">pb</span>(y);</span><br><span class="line">        v[y].<span class="built_in">pb</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i]);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## Day20：树上逆序对 链接：<a href="http://oj.daimayuan.top/course/10/problem/559">传送门</a> ###
题目描述 给定一个有根树，求有多少个<span class="math inline"><em>a</em><sub><em>i</em></sub> &lt; <em>f</em><sub><em>a</em><sub><em>i</em></sub></sub></span>。
### 范围 <span class="math inline"><em>n</em> ≤ 2 × 10<sup>5</sup></span> ### 思路
对于每一层，相当于求区间中小于<span class="math inline"><em>a</em><sub><em>i</em></sub></span>的数字的个数，可以树状数组离线求也可以主席树在线求。
### 代码 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> b[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span> <span class="params">(node a,node b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.v &lt; b.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x;i &lt;= m; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        c[i] += v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x;i;i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">        res += c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_query</span> &#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector &lt;_query&gt; q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i].v);</span><br><span class="line">        a[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>,a + n + <span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].v != a[i - <span class="number">1</span>].v) b[a[i].id] = ++m;</span><br><span class="line">        <span class="keyword">else</span> b[a[i].id] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; n;j ++) &#123;</span><br><span class="line">            <span class="type">int</span> l = j * (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">min</span>(n,i * j + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(l &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">            q[l].<span class="built_in">push_back</span>(&#123;<span class="number">-1</span>,b[i],j&#125;);</span><br><span class="line">            q[r].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>,b[i],j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">add</span>(b[i],<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;j : q[i]) &#123;</span><br><span class="line">            ans[j.id] += j.op * <span class="built_in">query</span>(j.v - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i ++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## Day21：约分 链接：<a href="http://oj.daimayuan.top/course/10/problem/560">传送门</a> ###
题目描述 给定一个分数，约分表示从分子分母中划掉相同数字，求最简分数。
### 范围 <span class="math inline">1 ≤ <em>a</em>, <em>b</em> ≤ 2<sup>63</sup> − 1</span>
### 思路 模拟。 ## Day22：蜗蜗的数列 链接：<a href="http://oj.daimayuan.top/course/10/problem/562">传送门</a> ###
题目描述 区间加斐波那契数列。 ### 范围 <span class="math inline"><em>n</em> ≤ 10<sup>6</sup>, <em>q</em> ≤ 10<sup>6</sup></span>
### 思路
根据定理，一个数列最多差分6次就成为了常数列，也就是说本题可以用差分。
考虑斐波那契的递推公式：<span class="math inline"><em>f</em><sub><em>i</em></sub> = <em>f</em><sub><em>i</em> − 1</sub> + <em>f</em><sub><em>i</em> − 2</sub></span>。
判断两个序列相等可以构造一个新数列<span class="math inline"><em>c</em><sub><em>i</em></sub> = <em>a</em><sub><em>i</em></sub> − <em>b</em><sub><em>i</em></sub></span>。
这个时候考虑区间加：<span class="math inline"><em>c</em><sub><em>i</em></sub> + <em>f</em><sub><em>j</em></sub></span>。
那么构造<span class="math inline"><em>d</em><sub><em>i</em></sub></span>
= <span class="math inline"><em>c</em><sub><em>i</em></sub> − <em>c</em><sub><em>i</em> − 1</sub> − <em>c</em><sub><em>i</em> − 2</sub></span>，每次的加减就相当于没变化，有变化的只有<span class="math inline"><em>l</em>, <em>r</em> + 1, <em>r</em> + 2</span>，线性维护即可。
### 代码 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,p;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line">ll d[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span> &lt;= x <span class="keyword">and</span> x &lt;= n) &#123;</span><br><span class="line">        ans -= (d[x] != <span class="number">0</span>);</span><br><span class="line">        d[x] = (d[x] + v) % p;</span><br><span class="line">        ans += (d[x] != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MOD</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(x,p - v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;m,&amp;p);</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        f[i] = (f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>]) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        d[i] += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        d[i] -= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>; i --) &#123;</span><br><span class="line">        d[i] = (d[i] - d[i - <span class="number">1</span>] - d[i - <span class="number">2</span>]) % p;</span><br><span class="line">        <span class="keyword">if</span>(d[i] &lt; <span class="number">0</span>) d[i] += p;</span><br><span class="line">        <span class="keyword">if</span>(d[i]) ans ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m --) &#123;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot; %c %d %d&quot;</span>,&amp;ch,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">add</span>(l,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">MOD</span>(r + <span class="number">1</span>,f[r - l + <span class="number">2</span>]);</span><br><span class="line">            <span class="built_in">MOD</span>(r + <span class="number">2</span>,f[r - l + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">MOD</span>(l,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">add</span>(r + <span class="number">1</span>,f[r - l + <span class="number">2</span>]);</span><br><span class="line">            <span class="built_in">add</span>(r + <span class="number">2</span>,f[r - l + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## Day23：最大公约数 链接：<a href="http://oj.daimayuan.top/course/10/problem/131">传送门</a> ###
题目描述 给定一个有<span class="math inline"><em>n</em></span>个数字的换，切分成<span class="math inline"><em>k</em></span>块，求每段和的最大公约数（最大）。
### 范围 <span class="math inline"><em>n</em> ≤ 2000, 1 ≤ <em>a</em><sub><em>i</em></sub> ≤ 5 × 10<sup>7</sup></span>
### 思路 考虑如果分成了<span class="math inline"><em>k</em></span>段，那么<span class="math inline"><em>g</em> = <em>g</em><em>c</em><em>d</em>(<em>d</em><sub>1</sub>, <em>d</em><sub>2</sub>, …, <em>d</em><sub><em>k</em></sub>)</span>。
设<span class="math inline"><em>a</em><sub><em>i</em></sub> = <em>k</em><sub><em>i</em></sub> × <em>g</em></span>，即<span class="math inline">$\sum_{i = 1}^{n}a_i = g * \sum_{i =
1}^{n}k_i$</span>，所以<span class="math inline"><em>g</em></span>为sum的一个因子，枚举sum的因子可以得到：对于因子<span class="math inline"><em>x</em></span>，每段总和都为<span class="math inline"><em>x</em></span>的倍数。
对于环来说，比数组多的就是头尾相和。</p>
<h3 id="代码-15">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        mp[s[i] % x] ++;</span><br><span class="line">        res = <span class="built_in">max</span>(res,mp[s[i] % x]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans[res] = <span class="built_in">max</span>(ans[res],x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">sqrt</span>(s[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k;i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[n] % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">solve</span>(i);</span><br><span class="line">            <span class="built_in">solve</span>(s[n] / i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n;i &gt;= <span class="number">1</span>; i --) &#123;</span><br><span class="line">        ans[i] = <span class="built_in">max</span>(ans[i],ans[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day24平方计数">Day24：平方计数</h2>
<p>链接：<a href="http://oj.daimayuan.top/course/10/problem/607">传送门</a> ###
题目描述 给定<span class="math inline"><em>n</em></span>个整数，求有多少对<span class="math inline">(<em>i</em>, <em>j</em>)</span>使得<span class="math inline"><em>a</em><sub><em>i</em></sub><sup>2</sup> + <em>a</em><em>j</em></span>是平方数。
### 范围 <span class="math inline"><em>n</em> ≤ 10<sup>6</sup>, 1 ≤ <em>a</em><sub><em>i</em></sub> ≤ 10<sup>6</sup></span>
### 思路 设<span class="math inline"><em>x</em><sup>2</sup></span>是个完全平方数，那么<span class="math inline"><em>a</em><sub><em>j</em></sub> = <em>x</em><sup>2</sup> − <em>a</em><sub><em>i</em></sub><sup>2</sup> = (<em>x</em> − <em>a</em><sub><em>i</em></sub>)(<em>x</em> + <em>a</em><sub><em>i</em></sub>)</span>
所以说对于每个元素枚举他的约数，如果两个约数的差是某个元素，那么就统计答案。
### 代码 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> mp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),mp[a[i]] ++;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= N - <span class="number">10</span>;i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i;j &lt;= N - <span class="number">10</span>;j += i) &#123;</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">max</span>(j / i,i);</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">min</span>(j / i,i);</span><br><span class="line">            <span class="type">int</span> c = r - l;</span><br><span class="line">            <span class="keyword">if</span>(c % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                ans += mp[j] * mp[c / <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ans &gt;&gt; <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## Day25：字典序最小 链接：<a href="http://oj.daimayuan.top/course/10/problem/608">传送门</a> ###
题目描述 给定一个序列，选出<span class="math inline"><em>m</em></span>个不同的数字，使得字典序最小。 ###
范围 <span class="math inline">1 ≤ <em>n</em>, <em>m</em> ≤ 10<sup>6</sup></span>
### 思路 考虑单调栈，如果一旦有小于栈顶的元素且没出现过，那么弹出插入。
弹出的条件也是需要后面还有这个元素，处理初始位置即可。 ### 代码
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C continue</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> stk[N];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        pre[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[a[i]]) C;</span><br><span class="line">        <span class="keyword">while</span>(top &gt; <span class="number">0</span> <span class="keyword">and</span> stk[top] &gt; a[i] <span class="keyword">and</span> pre[stk[top]] &gt; i) &#123;</span><br><span class="line">            vis[stk[top]] = <span class="number">0</span>;</span><br><span class="line">            top --;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++top] = a[i];</span><br><span class="line">        vis[a[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++) &#123;</span><br><span class="line">        cout &lt;&lt; stk[i];</span><br><span class="line">        <span class="keyword">if</span>(i != m) cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## Day26：拆拆 链接：<a href="http://oj.daimayuan.top/problem/611">传送门</a> ### 题目描述
给定两个数<span class="math inline"><em>x</em>, <em>y</em></span>问有多少个长度为<span class="math inline"><em>y</em></span>的整数序列乘积为<span class="math inline"><em>x</em></span>。 ### 范围 <span class="math inline">1 ≤ <em>T</em> ≤ 10<sup>5</sup>, 1 ≤ <em>x</em>, <em>y</em> ≤ 10<sup>6</sup></span>
### 思路
对每个数质因数分解之后，考虑将这些数排在一起做插空法，相当于<span class="math inline"><em>y</em></span>个盒子放数字，允许空盒（为1）的方案数。
<span class="math display"><em>a</em><em>n</em><em>s</em> = ∑<em>C</em><sub><em>n</em> + <em>m</em> − 1</sub><sup><em>m</em> − 1</sup></span>
### 代码 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mk(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">int</span> fac[N];</span><br><span class="line"><span class="type">int</span> inv[N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PI;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow_mod</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * a % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; N; i ++) fac[i] = (<span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i) % mod;</span><br><span class="line">    inv[N - <span class="number">1</span>] = <span class="built_in">pow_mod</span>(fac[N - <span class="number">1</span>],mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = N - <span class="number">2</span>;i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        inv[i] = (<span class="number">1ll</span> * inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span> <span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1ll</span> * fac[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vector &lt;PI&gt; c[N / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y : c[n]) &#123;</span><br><span class="line">        ans = ans * <span class="built_in">C</span>(y.second + m - <span class="number">1</span>,m - <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans * <span class="number">1ll</span> * <span class="built_in">pow_mod</span>(<span class="number">2</span>,m - <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span> ();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt; N / <span class="number">2</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i;j &lt; N / <span class="number">2</span>; j += i) &#123;</span><br><span class="line">            <span class="type">int</span> k = j;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(k % i == <span class="number">0</span>) k /= i,cnt ++;</span><br><span class="line">            c[j].<span class="built_in">push_back</span>(<span class="built_in">mk</span>(i,cnt));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="day27z型矩阵">Day27：Z型矩阵</h2>
<p>链接：<a href="http://oj.daimayuan.top/course/10/problem/614">传送门</a></p>
<h3 id="题目描述-1">题目描述</h3>
<p>给定一个<span class="math inline"><em>n</em> × <em>m</em></span>的矩阵，求里面有多少个子矩阵包含<span class="math inline"><em>z</em></span>。</p>
<h3 id="范围-13">范围</h3>
<p><span class="math inline"><em>n</em>, <em>m</em> ≤ 3000</span></p>
<h3 id="思路-7">思路</h3>
<p>枚举对角线，对于每一个对角线，每个z存下每行向左能到哪里，向右能到哪里。因此，对于一个连续z的对角线，每个z会有和之前的z的贡献并且本身会形成之后的贡献，线段树维护区间加区间求和。</p>
<h3 id="代码-16">代码</h3>
<p><a href="https://zhuanlan.zhihu.com/p/486600382"><span class="citation" data-cites="严格鸽">@严格鸽</span></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;del[<span class="number">2</span> * MAXN];</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;line[<span class="number">2</span> * MAXN];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//cnt 为对角线的长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="type">int</span> L = line[i].first, R = line[i].second;<span class="comment">//获得左右边</span></span><br><span class="line">        <span class="built_in">upd</span>(i, <span class="number">1</span>);<span class="comment">//增加贡献  注意这里我们是需要计算大小为1的Z的</span></span><br><span class="line">        ans += <span class="built_in">que</span>(<span class="built_in">max</span>(<span class="number">1</span>, i - R + <span class="number">1</span>), i);<span class="comment">//区间查询</span></span><br><span class="line">        del[<span class="built_in">min</span>(cnt, i + L - <span class="number">1</span>)].<span class="built_in">push_back</span>(i);<span class="comment">//记录删除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : del[i])<span class="built_in">upd</span>(x, <span class="number">-1</span>);<span class="comment">//遍历完了不要忘记删除贡献</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记得清空树状数组和del</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt + <span class="number">10</span>; i++)tree[i] = <span class="number">0</span>, del[i].<span class="built_in">clear</span>();</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m , g[MAXN][MAXN], L[MAXN][MAXN], R[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="type">char</span> ch; cin &gt;&gt; ch;</span><br><span class="line">            g[i][j] = (ch == <span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">if</span> (g[i][j])L[i][j] = L[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">            <span class="keyword">if</span> (g[i][j])R[i][j] = R[i][j + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">2</span>; d &lt;= n + m; d++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(<span class="number">1</span>, d - m); i &lt;= <span class="built_in">min</span>(n, d - <span class="number">1</span>); i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = d - i;</span><br><span class="line">            <span class="keyword">if</span> (!g[i][j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt) <span class="built_in">solve_line</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                line[++cnt] = &#123; L[i][j], R[i][j] &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt) <span class="built_in">solve_line</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="day28好序列">Day28：好序列</h2>
<p>链接：<a href="https://zhuanlan.zhihu.com/p/487136369">传送门</a></p>
<h3 id="题目描述-2">题目描述</h3>
<p>给定一个序列，如果这个序列所有子区间都有至少一个出现一次的数字，则是好的，否则不好。</p>
<h3 id="范围-14">范围</h3>
<p><span class="math inline">1 ≤ <em>n</em> ≤ 2 × 10<sup>5</sup>, ∑<em>n</em> ≤ 10<sup>6</sup>, 1 ≤ <em>A</em><sub><em>i</em></sub> ≤ 10<sup>9</sup></span></p>
<h3 id="思路-8">思路</h3>
<p>一，启发式合并：</p>
<p>对于每个值存上一个出现位置和下一个出现位置，也就是说满足<span class="math inline"><em>p</em><em>r</em><em>e</em>[<em>x</em>] &lt; <em>x</em> &lt; <em>n</em><em>e</em><em>x</em><em>t</em>[<em>x</em>]</span>那么就是出现一次。因此启发式合并，每个较小的区间合并到较大的，这样均摊下来就是<span class="math inline"><em>O</em>(<em>n</em><em>l</em><em>o</em><em>g</em><em>n</em>)</span></p>
<p>二，线段树</p>
<p>问题其实就是在知道了之前的结果之后，每次新加一个数字，找之前和他一样的，区间查询和即可。</p>
<h3 id="代码-17">代码</h3>
<p>Code1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="type">int</span> nxt[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">split</span> <span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="type">int</span> x = l;</span><br><span class="line">	<span class="type">int</span> y = r;</span><br><span class="line">	<span class="keyword">while</span>(x &lt;= y) &#123;</span><br><span class="line">		<span class="keyword">if</span>(pre[x] &lt; l <span class="keyword">and</span> r &lt; nxt[x]) <span class="keyword">return</span> <span class="built_in">split</span>(l,x - <span class="number">1</span>) &amp;&amp; <span class="built_in">split</span>(x + <span class="number">1</span>,r);</span><br><span class="line">		<span class="keyword">if</span>(pre[y] &lt; l <span class="keyword">and</span> r &lt; nxt[y]) <span class="keyword">return</span> <span class="built_in">split</span>(l,y - <span class="number">1</span>) &amp;&amp; <span class="built_in">split</span>(y + <span class="number">1</span>,r);</span><br><span class="line">		x ++;</span><br><span class="line">		y --;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	map &lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">		pre[i] = <span class="number">-1</span>;</span><br><span class="line">		nxt[i] = n + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">		pre[i] = mp[a[i]];</span><br><span class="line">		nxt[mp[a[i]]] = i;</span><br><span class="line">		mp[a[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">split</span>(<span class="number">1</span>,n)) <span class="built_in">puts</span>(<span class="string">&quot;non-boring&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;boring&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T --) <span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Code2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pre;</span><br><span class="line"><span class="type">int</span> root[MAXN], cur, ls[MAXN * <span class="number">40</span>], rs[MAXN * <span class="number">40</span>], minv[MAXN * <span class="number">40</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pre.<span class="built_in">clear</span>();</span><br><span class="line">    cur = <span class="number">0</span>;</span><br><span class="line">    ls[cur] = rs[cur] = <span class="number">0</span>;</span><br><span class="line">    minv[cur] = INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">(<span class="type">int</span> old)</span> </span>&#123;</span><br><span class="line">    cur++;</span><br><span class="line">    ls[cur] = ls[old];</span><br><span class="line">    rs[cur] = rs[old];</span><br><span class="line">    minv[cur] = minv[old];</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushUp</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">    minv[now] = <span class="built_in">min</span>(minv[ls[now]], minv[rs[now]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> old, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> now = <span class="built_in">newNode</span>(old);</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        minv[now] = v;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) ls[now] = <span class="built_in">insert</span>(ls[now], l, mid, x, v);</span><br><span class="line">    <span class="keyword">else</span> rs[now] = <span class="built_in">insert</span>(rs[now], mid + <span class="number">1</span>, r, x, v);</span><br><span class="line">    <span class="built_in">pushUp</span>(now);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> o, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ans != <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R &amp;&amp; minv[o] &gt;= v) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        ans = l;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">query</span>(ls[o], l, mid, L, R, v);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; R) <span class="built_in">query</span>(rs[o], mid<span class="number">+1</span>, r, L, R, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">query</span>(root[r], <span class="number">1</span>, n, l, r, l);</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check</span>(l, ans - <span class="number">1</span>) &amp;&amp; <span class="built_in">check</span>(ans + <span class="number">1</span>, r)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        root[i] = <span class="built_in">insert</span>(root[i - <span class="number">1</span>], <span class="number">1</span>, n, i, pre[x]);</span><br><span class="line">        <span class="keyword">if</span>(pre[x]) root[i] = <span class="built_in">insert</span>(root[i], <span class="number">1</span>, n, pre[x], INF);</span><br><span class="line">        pre[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="built_in">check</span>(<span class="number">1</span>, n) ? <span class="string">&quot;non-boring&quot;</span> : <span class="string">&quot;boring&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= T; i++) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>2022 Namomo Camp</category>
      </categories>
      <tags>
        <tag>Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Infinite Set</title>
    <url>/2022-03-10-Infinite-Set.html</url>
    <content><![CDATA[#
<center>
Infinite Set
</center>
<span id="more"></span>
<h2 id="题目描述">题目描述</h2>
<p>给定一个无限集合<span class="math inline"><em>S</em></span>满足：</p>
<p>1.包含<span class="math inline"><em>A</em></span>序列</p>
<p>2.对于每个<span class="math inline"><em>x</em> ∈ <em>S</em></span>,<span class="math inline"><em>y</em> = 2<em>x</em> + 1 ∈ <em>S</em></span></p>
<p>3.对于每个<span class="math inline"><em>x</em> ∈ <em>S</em>, <em>y</em> = 4<em>x</em> ∈ <em>S</em></span></p>
<p>求出小于<span class="math inline">2<sup><em>p</em></sup></span>的数字个数对<span class="math inline">10<sup>9</sup> + 7</span>取模</p>
<h2 id="范围">范围</h2>
<p><span class="math inline"><em>n</em>, <em>p</em> ≤ 2 × 10<sup>5</sup></span></p>
<h2 id="思路">思路</h2>
<p>可以看到，2、3操作就是相当于：<span class="math inline"><em>x</em> &lt;  &lt; 1|1, <em>x</em> &lt;  &lt; 2</span></p>
<p>因此可以考虑设<span class="math inline"><em>f</em><sub><em>i</em></sub></span>表示二进制最高位<span class="math inline"><em>i</em></span>的满足条件的数字有多少？</p>
<p>那么：</p>
<p><span class="math display">$$
f_{i + 1} += f_i \\
f_{i + 2} += f_i
$$</span></p>
<p>但是，你需要将现有的<span class="math inline"><em>A</em></span>中去重，复杂度<span class="math inline"><em>O</em>(<em>p</em>)</span></p>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; v;</span><br><span class="line">map &lt;<span class="type">int</span>,<span class="type">bool</span>&gt; mp;</span><br><span class="line">ll f[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            x /= <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span>(mp[x]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            x = (x - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mp[x]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cut</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        cnt ++;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[cnt] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,p;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        mp[a[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>,a + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(a[i])) &#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : v) <span class="built_in">cut</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= p; i ++) &#123;</span><br><span class="line">        f[i + <span class="number">1</span>] = (f[i + <span class="number">1</span>] + f[i]) % mod;</span><br><span class="line">        f[i + <span class="number">2</span>] = (f[i + <span class="number">2</span>] + f[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= p;i ++) &#123;</span><br><span class="line">        ans = (ans + f[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>dp</category>
        <category>二进制dp</category>
      </categories>
      <tags>
        <tag>二进制dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduction to Probability,2E</title>
    <url>/2022-02-23-Introduction-to-Probability-2E.html</url>
    <content><![CDATA[#
<center>
《Introduction to Probability》2E
</center>
<span id="more"></span>
<h2 id="chap1">Chap1</h2>
<p><a href="https://www.cnblogs.com/Allorkiya/articles/15750155.html">Chap1</a></p>
<h2 id="chap2">Chap2</h2>
<p><a href="https://www.cnblogs.com/Allorkiya/articles/15769121.html">Chap2</a></p>
<h2 id="chap3">Chap3</h2>
<p><a href="https://www.cnblogs.com/Allorkiya/articles/15773043.html">Chap3</a></p>
<h2 id="chap4">Chap4</h2>
<p><a href="https://www.cnblogs.com/Allorkiya/articles/15776771.html">Chap4</a></p>
<h2 id="chap5">Chap5</h2>
<p><a href="https://www.cnblogs.com/Allorkiya/articles/15781866.html">Chap5</a></p>
<h2 id="chap6">Chap6</h2>
<p><a href="https://www.cnblogs.com/Allorkiya/articles/15835178.html">Chap6</a></p>
]]></content>
      <categories>
        <category>Math</category>
        <category>Probability</category>
      </categories>
      <tags>
        <tag>Probability</tag>
        <tag>Math</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Kaggle-Titanic-Solution</title>
    <url>/2022-02-24-Kaggle-Titanic-Solution.html</url>
    <content><![CDATA[#
<center>
Titanic
</center>
<p>Kaggle中入门题Titanic的解决方案。</p>
<span id="more"></span>
<h2 id="version1">Version——1</h2>
<p>纪念2022年2月24日于Kaggle平台做出ML的<code>Hello World</code>题。</p>
<p><code>Scrore:77.5</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure>
<h3 id="step-1.数据读入">Step 1.数据读入</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train = pd.read_csv(<span class="string">&#x27;/kaggle/input/titanic/train.csv&#x27;</span>)</span><br><span class="line">test = pd.read_csv(<span class="string">&#x27;/kaggle/input/titanic/test.csv&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(train.head())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">40</span>)</span><br><span class="line"><span class="built_in">print</span>(train.info())</span><br></pre></td></tr></table></figure>
<p>通过展示结果可以发现，<code>Age,Cabin,Embarked</code>列存在缺失值；并且<code>Name,Sex,Ticket,Cabin,Embarked</code>不是学习可用的数值型，需要进行数据转换。</p>
<h3 id="step-2.-数据预处理">Step 2. 数据预处理</h3>
<p>填充缺失值的时候需要根据缺失值的类型填充：</p>
<ul>
<li>如果数据集很大，缺失值很少，直接删除即可。</li>
<li>如果数据缺失值可能代表空值，那么用一个新的唯一地变量替代缺失值。</li>
<li>如果数据分析下来很重要，需要通过随机森林回归或线性回归等手段预测。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize = (<span class="number">10</span>,<span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">train[<span class="string">&#x27;Age&#x27;</span>].hist(bins = <span class="number">80</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Age&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Num&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">train.boxplot(column = <span class="string">&#x27;Age&#x27;</span>,showfliers = <span class="literal">False</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2022-02-24-Kaggle-Titanic-Solution/1.png" class title="年龄分布图">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fct = sns.FacetGrid(train,hue = <span class="string">&#x27;Survived&#x27;</span>,aspect = <span class="number">5</span>)</span><br><span class="line">fct.<span class="built_in">map</span>(sns.kdeplot,<span class="string">&#x27;Age&#x27;</span>,shade = <span class="literal">True</span>)</span><br><span class="line">fct.<span class="built_in">set</span>(xlim = (<span class="number">0</span>,train[<span class="string">&#x27;Age&#x27;</span>].<span class="built_in">max</span>()))</span><br><span class="line">fct.add_legend()</span><br></pre></td></tr></table></figure>
<p>使用seaborn库绘制不同年龄下存存活和死亡的人的概率密度（核密度估计）。</p>
<p>这里解释下，核密度估计大概就是分布在某个点附近的点的多少，可以大概地看出来每个点地人数有多少。</p>
<img src="/2022-02-24-Kaggle-Titanic-Solution/2.png" class title="不同年龄生存情况的核密度估计图">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize = (<span class="number">18</span>,<span class="number">4</span>))</span><br><span class="line">new_df = train.dropna(how = <span class="string">&#x27;any&#x27;</span>,subset = [<span class="string">&#x27;Survived&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>])</span><br><span class="line">new_df[<span class="string">&quot;Age_int&quot;</span>] = new_df[<span class="string">&quot;Age&quot;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(new_df.info())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span> * <span class="number">40</span>)</span><br><span class="line">aver = new_df[[<span class="string">&quot;Age_int&quot;</span>,<span class="string">&quot;Survived&quot;</span>]].groupby([<span class="string">&#x27;Age_int&#x27;</span>],as_index = <span class="literal">False</span>).mean()</span><br><span class="line">sns.barplot(x = <span class="string">&#x27;Age_int&#x27;</span>,y = <span class="string">&#x27;Survived&#x27;</span>,data = aver)</span><br></pre></td></tr></table></figure>
<img src="/2022-02-24-Kaggle-Titanic-Solution/3.png" class title="不同年龄活下来的人的占比">
<p>因此可以看出<code>Age</code>对于学习有着很大的影响，因此使用随机森林预测缺失值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">limit = [<span class="number">0</span>,<span class="number">12</span>,<span class="number">18</span>,<span class="number">64</span>,<span class="number">99</span>]</span><br><span class="line">train[<span class="string">&#x27;Age_Group&#x27;</span>] = pd.cut(train[<span class="string">&#x27;Age&#x27;</span>],limit)</span><br><span class="line">class_age = train.groupby(<span class="string">&#x27;Age_Group&#x27;</span>)[<span class="string">&#x27;Survived&#x27;</span>].mean()</span><br><span class="line">class_age</span><br><span class="line">class_age.plot(kind = <span class="string">&#x27;bar&#x27;</span>)</span><br></pre></td></tr></table></figure>
<img src="/2022-02-24-Kaggle-Titanic-Solution/4.png" class title="不同年龄段的平均存活率">
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line">age_df = train[[<span class="string">&#x27;Age&#x27;</span>,<span class="string">&#x27;Survived&#x27;</span>,<span class="string">&#x27;Fare&#x27;</span>,<span class="string">&#x27;Parch&#x27;</span>,<span class="string">&#x27;SibSp&#x27;</span>,<span class="string">&#x27;Pclass&#x27;</span>]]</span><br><span class="line">age_df_notnull = age_df.loc[(train[<span class="string">&#x27;Age&#x27;</span>].notnull())]</span><br><span class="line">age_df_isnull = age_df.loc[(train[<span class="string">&#x27;Age&#x27;</span>].isnull())]</span><br><span class="line">X = age_df_notnull.values[:,<span class="number">1</span>:] <span class="comment">#use others to predict Age</span></span><br><span class="line">Y = age_df_notnull.values[:,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">RFR = RandomForestRegressor(n_estimators = <span class="number">1000</span>,n_jobs = -<span class="number">1</span>)</span><br><span class="line">RFR.fit(X,Y)</span><br><span class="line">predict_Age = RFR.predict(age_df_isnull.values[:,<span class="number">1</span>:]) <span class="comment">#to predict NULL_AGE row </span></span><br><span class="line">train.loc[train[<span class="string">&#x27;Age&#x27;</span>].isnull(),[<span class="string">&#x27;Age&#x27;</span>]] = predict_Age</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train.info()</span><br></pre></td></tr></table></figure>
<p><code>Age</code>缺失值填充完毕，接下来是<code>Cabin,Embarked</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train.head()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train.Cabin[train.Cabin.isnull()] = <span class="string">&#x27;NO&#x27;</span></span><br><span class="line">train.Embarked[train.Embarked.isnull()] = train.Embarked.dropna().mode().values</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train.head()</span><br></pre></td></tr></table></figure>
<p>数据转换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train.loc[train[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&quot;female&quot;</span>,<span class="string">&#x27;Sex&#x27;</span>] = <span class="number">0</span></span><br><span class="line">train.loc[train[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&quot;male&quot;</span>,<span class="string">&#x27;Sex&#x27;</span>] = <span class="number">1</span></span><br><span class="line">train.loc[train[<span class="string">&#x27;Embarked&#x27;</span>] == <span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;Embarked&#x27;</span>] = <span class="number">0</span></span><br><span class="line">train.loc[train[<span class="string">&#x27;Embarked&#x27;</span>] == <span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;Embarked&#x27;</span>] = <span class="number">1</span></span><br><span class="line">train.loc[train[<span class="string">&#x27;Embarked&#x27;</span>] == <span class="string">&#x27;Q&#x27;</span>,<span class="string">&#x27;Embarked&#x27;</span>] = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train.head()</span><br></pre></td></tr></table></figure>
<p>选出两个新的特征：家庭成员数量以及名字长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train[<span class="string">&#x27;family_size&#x27;</span>] = train[<span class="string">&#x27;SibSp&#x27;</span>] + train[<span class="string">&#x27;Parch&#x27;</span>] + <span class="number">1</span></span><br><span class="line">train[<span class="string">&#x27;name_length&#x27;</span>] = train[<span class="string">&#x27;Name&#x27;</span>].apply(<span class="keyword">lambda</span> x : <span class="built_in">len</span>(x))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train.head()</span><br></pre></td></tr></table></figure>
<p>使用<code>SelectKBest</code>选出4个特征，并打分，选出4个最好的特征。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line">base = [<span class="string">&#x27;Pclass&#x27;</span>,<span class="string">&#x27;Sex&#x27;</span>,<span class="string">&#x27;Age&#x27;</span>,<span class="string">&#x27;SibSp&#x27;</span>,<span class="string">&#x27;Parch&#x27;</span>,<span class="string">&#x27;Fare&#x27;</span>,<span class="string">&#x27;Embarked&#x27;</span>,<span class="string">&#x27;family_size&#x27;</span>,<span class="string">&#x27;name_length&#x27;</span>]</span><br><span class="line">selector = SelectKBest(k = <span class="number">4</span>)</span><br><span class="line">selector.fit(train[base],train[<span class="string">&#x27;Survived&#x27;</span>])</span><br><span class="line">scores = -np.log10(selector.pvalues_)</span><br><span class="line">plt.bar(<span class="built_in">range</span>(<span class="built_in">len</span>(base)),scores)</span><br><span class="line">plt.xticks(<span class="built_in">range</span>(<span class="built_in">len</span>(base)),base,rotation = <span class="string">&#x27;vertical&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src="/2022-02-24-Kaggle-Titanic-Solution/5.png" class title="指标得分情况">
<h3 id="step-3.-xgboost学习">Step 3. XGBoost学习</h3>
<p>选`<code>Pclass,Sex,Fare and name_length</code>这四个变量，使用集成算法<code>XGBoost</code>进行预测。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train = train[[<span class="string">&#x27;Pclass&#x27;</span>,<span class="string">&#x27;Sex&#x27;</span>,<span class="string">&#x27;Fare&#x27;</span>,<span class="string">&#x27;name_length&#x27;</span>]]</span><br><span class="line">Y_train = train[[<span class="string">&#x27;Survived&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test.info()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test.loc[test[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;male&#x27;</span>,[<span class="string">&#x27;Sex&#x27;</span>]] = <span class="number">1</span></span><br><span class="line">test.loc[test[<span class="string">&#x27;Sex&#x27;</span>] == <span class="string">&#x27;female&#x27;</span>,[<span class="string">&#x27;Sex&#x27;</span>]] = <span class="number">0</span></span><br><span class="line">test[<span class="string">&#x27;name_length&#x27;</span>] = test[<span class="string">&#x27;SibSp&#x27;</span>] + test[<span class="string">&#x27;Parch&#x27;</span>] + <span class="number">1</span></span><br><span class="line">X_test = test[[<span class="string">&#x27;Pclass&#x27;</span>,<span class="string">&#x27;Sex&#x27;</span>,<span class="string">&#x27;Fare&#x27;</span>,<span class="string">&#x27;name_length&#x27;</span>]]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBClassifier</span><br><span class="line"></span><br><span class="line">MODEL = XGBClassifier(</span><br><span class="line">    learning_rate = <span class="number">0.01</span>,</span><br><span class="line">    n_estimators = <span class="number">11</span>,</span><br><span class="line">    max_depth = <span class="number">10</span>,</span><br><span class="line">    min_child_weight = <span class="number">1</span>,</span><br><span class="line">    gamma = <span class="number">0.</span>,</span><br><span class="line">    subsample = <span class="number">1</span>,</span><br><span class="line">    colsample_btree = <span class="number">1</span>,</span><br><span class="line">    scale_pos_weight = <span class="number">1</span>,</span><br><span class="line">    random_state = <span class="number">19</span>,</span><br><span class="line">    slient = <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">MODEL.fit(X_train.values,Y_train.values)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Y_pred = MODEL.predict(X_test.values)</span><br><span class="line">Output = pd.DataFrame(&#123;<span class="string">&#x27;PassengerId&#x27;</span>: test.PassengerId, <span class="string">&#x27;Survived&#x27;</span>: Y_pred&#125;)</span><br><span class="line">Output.to_csv(<span class="string">&#x27;submission.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Your submission was successfully saved!&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Competitions</category>
        <category>Easy</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Kaggle</tag>
        <tag>XGBoost</tag>
        <tag>RandomForest</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning Summary</title>
    <url>/2022-02-24-Machine-Learning-Summary.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh,there's something wrong.Check and try again." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="155fc8f4c2ed64bd9aba41b03993cada72f1a8627ee3317703e1772d01e21d68">66740834d64ef9f31f5fe3f08882fdc30c572ae9aee897ad6dac272c513db714e8b3733a4f25632cf121ab00e07596ee4d3543ca0742f2a7dd257391b980978a9ea8429f9749199874fdcb8b7b07161c2b4e6e3c591748930cc1e3cf30e03ee3171acfe8ae097a428e1ead5f1d1e03ff87e8bacef7758b2a1f134fa78d85dcfaa3939fe77c184d29f95b20a280718c42</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Summary</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Namomo Subsequence</title>
    <url>/2022-03-08-Namomo-Subsequence.html</url>
    <content><![CDATA[#
<center>
2020 ECF A Namomo Subsequence
</center>
<span id="more"></span>
<h2 id="题目描述">题目描述</h2>
<p>给定一个字符串，求有多少个形如<span class="math inline"><em>A</em><em>B</em><em>C</em><em>D</em><em>C</em><em>D</em></span>的子序列，对<span class="math inline">998244353</span>取模</p>
<h2 id="范围">范围</h2>
<p><span class="math inline"><em>n</em> ≤ 1000000</span>，字符集<span class="math inline">|<em>S</em>| ≤ 62</span></p>
<h2 id="思路">思路</h2>
<p>我们考虑只需要枚举C，那么答案就是<span class="math inline"><em>A</em><em>B</em></span>的个数乘<span class="math inline"><em>D</em><em>C</em><em>D</em></span>的个数，考虑<span class="math inline"><em>A</em><em>B</em></span>的个数可以通过容斥来算，维护每个字符的前缀和计算即可。CD也同理，维护<span class="math inline"><em>D</em><em>C</em><em>D</em></span>数组，正常计算即可。</p>
<p>PS：需要常数写的比较小，能少取模就少取，感谢大佬！</p>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">65</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">map &lt;<span class="type">char</span> ,<span class="type">int</span>&gt; mp;</span><br><span class="line">ll f[M][M][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> c[N][M];</span><br><span class="line">ll tt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow_mod</span> <span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = <span class="number">1ll</span> * res * a % mod;</span><br><span class="line">        a = <span class="number">1ll</span> * a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;++i) &#123;</span><br><span class="line">        mp[i + <span class="string">&#x27;a&#x27;</span>] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>; ++ i) &#123;</span><br><span class="line">        mp[i + <span class="string">&#x27;A&#x27;</span>] = <span class="number">26</span> + <span class="number">1</span> + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">9</span>; ++ i) &#123;</span><br><span class="line">        mp[i + <span class="string">&#x27;0&#x27;</span>] = <span class="number">52</span> + i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ll ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++ i) &#123;</span><br><span class="line">        a[i] = mp[s[i - <span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">62</span>;++ j) &#123;</span><br><span class="line">            c[i][j] = c[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        c[i][a[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll two = <span class="built_in">pow_mod</span>(<span class="number">2</span>,mod - <span class="number">2</span>) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; -- i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">62</span>; ++ j)</span><br><span class="line">            tt[i] += (ll)c[i - <span class="number">1</span>][j] * (c[i - <span class="number">1</span>][j] - <span class="number">1</span>);</span><br><span class="line">        tt[i] = tt[i] % mod * two % mod;</span><br><span class="line">        <span class="type">int</span> tmp0 = two * (i - <span class="number">1</span>) % mod * (i - <span class="number">2</span>) % mod;</span><br><span class="line">        <span class="type">int</span> tmp1 = (ll)c[i - <span class="number">1</span>][a[i]] * (i - <span class="number">1</span> - c[i - <span class="number">1</span>][a[i]]) % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">62</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == j) <span class="keyword">continue</span>;</span><br><span class="line">            ll tmp = f[a[i]][j][<span class="number">1</span>] % mod + mod;</span><br><span class="line">            f[a[i]][j][<span class="number">2</span>] += c[n][j] - c[i - <span class="number">1</span>][j];</span><br><span class="line">            f[j][a[i]][<span class="number">1</span>] += f[j][a[i]][<span class="number">2</span>];</span><br><span class="line">            ans += ( tmp0 - (tt[i] + tmp1 + (ll)c[i - <span class="number">1</span>][j] * (i - <span class="number">1</span> - c[i - <span class="number">1</span>][j]) - (ll)c[i - <span class="number">1</span>][a[i]] * c[i - <span class="number">1</span>][j])) % mod * tmp % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (ans % mod + mod) % mod &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>dp</category>
        <category>计数dp</category>
      </categories>
      <tags>
        <tag>计数dp</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Outer space invaders</title>
    <url>/2022-03-04-Outer-space-invaders.html</url>
    <content><![CDATA[#
<center>
[CERC2014] Outer space invaders
</center>
<span id="more"></span>
<p>链接：<a href="https://vjudge.net/contest/482141#problem/E">传送门</a></p>
<h2 id="题目描述">题目描述</h2>
<p>给定<span class="math inline"><em>n</em></span>个外星人，第<span class="math inline"><em>i</em></span>个会在<span class="math inline"><em>a</em><sub><em>i</em></sub></span>出现，<span class="math inline"><em>b</em><sub><em>i</em></sub></span>之前必须消灭，距离为<span class="math inline"><em>d</em><sub><em>i</em></sub></span>。每次攻击可以消灭半径为<span class="math inline"><em>r</em></span>内的敌人，并且消耗<span class="math inline"><em>r</em></span>单位的能源，问消灭所有的外星人最少小号多少能源？</p>
<h2 id="范围">范围</h2>
<p><span class="math inline"><em>n</em> ≤ 300, <em>a</em><sub><em>i</em></sub>, <em>b</em><sub><em>i</em></sub>, <em>d</em><sub><em>i</em></sub> ≤ 10000</span></p>
<h2 id="思路">思路</h2>
<p>区间dp，设<span class="math inline"><em>f</em><sub><em>i</em>, <em>j</em></sub></span>表示消灭出现和消灭时间范围都在<span class="math inline">[<em>i</em>, <em>j</em>]</span>中的敌人的最少能源，考虑怎么转移：</p>
<p>找到区间范围内距离最远的敌人，这样保证是可以最优的。之后将不包含该敌人的两个区间合并，注意时间的离散化！</p>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">610</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> q = <span class="number">0</span>,f= <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)f = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        q = q * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> b[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span>  <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --) &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">read</span>();</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">            a[i] = <span class="built_in">read</span>(),b[i] = <span class="built_in">read</span>(),d[i] = <span class="built_in">read</span>();</span><br><span class="line">            q[++cnt] = a[i];</span><br><span class="line">            q[++cnt] = b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(q + <span class="number">1</span>,q + cnt + <span class="number">1</span>);</span><br><span class="line">        cnt = <span class="built_in">unique</span>(q + <span class="number">1</span>,q + cnt + <span class="number">1</span>) - q - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">            a[i] = <span class="built_in">lower_bound</span>(q + <span class="number">1</span>,q + cnt + <span class="number">1</span>,a[i]) - q;</span><br><span class="line">            b[i] = <span class="built_in">lower_bound</span>(q + <span class="number">1</span>,q + cnt + <span class="number">1</span>,b[i]) - q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= cnt; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= cnt; j ++) &#123;</span><br><span class="line">                f[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>;l &lt;= cnt;l ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i + l - <span class="number">1</span> &lt;= cnt;i ++) &#123;</span><br><span class="line">                <span class="type">int</span> j = i + l - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n; k ++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i &lt;= a[k] <span class="keyword">and</span> b[k] &lt;= j <span class="keyword">and</span> d[k] &gt; d[x]) x = k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(x == <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = a[x];k &lt;= b[x];k ++) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j],f[i][k - <span class="number">1</span>] + d[x] + f[k + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; f[<span class="number">1</span>][cnt] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>dp</category>
        <category>区间dp</category>
      </categories>
      <tags>
        <tag>CERC</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Paint</title>
    <url>/2022-03-04-Paint.html</url>
    <content><![CDATA[#
<center>
Paint
</center>
<span id="more"></span>
<p>链接：<a href="https://vjudge.net/contest/482141#problem/D">传送门</a></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个颜色序列，每次能够选择一段涂成某种颜色，请问将<span class="math inline">[1, <em>n</em>]</span>涂成相同颜色的最少步数是多少？</p>
<h2 id="范围">范围</h2>
<p><span class="math inline"><em>n</em> ≤ 3000, <em>t</em> ≤ 3000, <em>a</em><sub><em>i</em></sub> ≤ <em>n</em></span></p>
<h2 id="思路">思路</h2>
<p>设<span class="math inline"><em>f</em><sub><em>i</em>, <em>j</em></sub></span>表示将<span class="math inline">[<em>i</em>, <em>j</em>]</span>填成<span class="math inline"><em>j</em></span>颜色的最小步数，答案就为<span class="math inline"><em>f</em><sub>1, <em>n</em></sub></span></p>
<p>注意连续的一段没有贡献，因此将其缩成一个点。</p>
<p>转移： <span class="math display">$$
f_{i,j} = min(f_{i,j - 1},f_{i + 1,j}) + 1 \\
f_{i,j} = min(f_{i,k} + f_{k + 1,j}) \\
$$</span></p>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> b[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T --) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) vis[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p &lt;= n) &#123;</span><br><span class="line">            <span class="type">int</span> t = p;</span><br><span class="line">            <span class="keyword">while</span> (t &lt;= n <span class="keyword">and</span> b[t] == b[p]) &#123;</span><br><span class="line">                t ++;</span><br><span class="line">            &#125;</span><br><span class="line">            a[++cnt] = b[p];</span><br><span class="line">            p = t;</span><br><span class="line">        &#125;<span class="comment">//找连续段</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= cnt; i ++) &#123;</span><br><span class="line">            pre[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(vis[a[i]]) &#123;</span><br><span class="line">                pre[i] = vis[a[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            vis[a[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= cnt; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= cnt; j ++) &#123;</span><br><span class="line">                f[i][j] = INF;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= cnt; i ++) &#123;</span><br><span class="line">            f[i][i] = f[i + <span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span>;k &lt;= cnt;k ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i + k - <span class="number">1</span> &lt;= cnt;i ++) &#123;</span><br><span class="line">                <span class="type">int</span> j = i + k - <span class="number">1</span>;</span><br><span class="line">                f[i][j] = <span class="built_in">min</span>(f[i][j - <span class="number">1</span>],f[i + <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> t = pre[j];t &gt;= i;t = pre[t]) &#123;</span><br><span class="line">                    f[i][j] = <span class="built_in">min</span>(f[i][j],f[i][t] + f[t + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; f[<span class="number">1</span>][cnt] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>dp</category>
        <category>区间dp</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Prime Distance</title>
    <url>/2022-03-01-Prime-Distance.html</url>
    <content><![CDATA[#
<center>
Prime Distance
</center>
<span id="more"></span>
<p>链接：<a href="https://ac.nowcoder.com/acm/contest/21094/C">传送门</a></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个区间，求出区间内素数最大距离、最小距离以及它们的数分别是多少？</p>
<h2 id="范围">范围</h2>
<p><span class="math inline"><em>T</em> ≤ 1000; <em>l</em>, <em>r</em> ≤ 10<sup>9</sup>, (<em>r</em> − <em>l</em>) ≤ 10<sup>6</sup></span></p>
<h2 id="解法">解法</h2>
<p>筛一下1e5之内的素数，枚举每个素数在<span class="math inline">[<em>l</em>, <em>r</em>]</span>内的倍数筛掉，之后求最值即可。</p>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">int</span> primes[N];</span><br><span class="line"><span class="type">bool</span> np[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(np,<span class="number">0</span>,<span class="keyword">sizeof</span> np);</span><br><span class="line">    np[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">100000</span>;i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!np[i]) &#123;</span><br><span class="line">            primes[++tot] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot <span class="keyword">and</span> i * primes[j] &lt;= <span class="number">100000</span>;j ++) &#123;</span><br><span class="line">            np[i * primes[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_lr</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= tot;i ++) &#123;</span><br><span class="line">        <span class="type">int</span> p = l / primes[i];</span><br><span class="line">        <span class="keyword">while</span>(p &lt;= <span class="number">1</span>) p ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = p * primes[i];j &lt;= r;j += primes[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= l) &#123;</span><br><span class="line">                vis[j - l] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l == <span class="number">1</span>) vis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sieve</span> ();</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="built_in">get_lr</span>(l,r);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= r - l;i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">                d[++cnt] = i + l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;There are no adjacent primes.\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> Mx = -INF;</span><br><span class="line">            <span class="type">int</span> Mn = INF;</span><br><span class="line">            <span class="type">int</span> mnl,mnr,mxl,mxr;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt; cnt; i ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(d[i + <span class="number">1</span>] - d[i] &gt; Mx) &#123;</span><br><span class="line">                    Mx = d[i + <span class="number">1</span>] - d[i];</span><br><span class="line">                    mxl = d[i];</span><br><span class="line">                    mxr = d[i + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(d[i + <span class="number">1</span>] - d[i] &lt; Mn) &#123;</span><br><span class="line">                    Mn = d[i + <span class="number">1</span>] - d[i];</span><br><span class="line">                    mnl = d[i];</span><br><span class="line"></span><br><span class="line">                    mnr = d[i + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d,%d are closest, %d,%d are most distant.\n&quot;</span>,mnl,mnr,mxl,mxr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>Math Theory</category>
        <category>Primes Sieve</category>
      </categories>
      <tags>
        <tag>Primes Sieve</tag>
      </tags>
  </entry>
  <entry>
    <title>Towers</title>
    <url>/2022-03-04-Towers.html</url>
    <content><![CDATA[#
<center>
Towers
</center>
<center>
Codeforces 1637F Towers
</center>
<span id="more"></span>
<p>链接：<a href="https://vjudge.net/contest/482141#problem/B">传送门</a></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个<span class="math inline"><em>n</em></span>个节点的树，需要构造一些节点的权值，满足对于任何一个点<span class="math inline"><em>x</em></span>，都有经过点的一条链，满足<span class="math inline"><em>m</em><em>i</em><em>n</em>(<em>w</em><sub><em>u</em></sub>, <em>w</em><sub><em>v</em></sub>) &gt;  = <em>w</em><sub><em>x</em></sub></span></p>
<h2 id="范围">范围</h2>
<p><span class="math inline"><em>n</em> ≤ 2 × 10<sup>5</sup>, <em>h</em><sub><em>i</em></sub> ≤ 10<sup>9</sup></span></p>
<h2 id="思路">思路</h2>
<p>考虑一种显然的构造方法，先找一个最大的点，两端构造两个点的权值等于最大点权值，之后对于子树每一个点重复类似过程。</p>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> mx1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mx2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y : v[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        <span class="keyword">if</span>(ret &gt; mx1) &#123;</span><br><span class="line">            mx2 = mx1;</span><br><span class="line">            mx1 = ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; mx2) &#123;</span><br><span class="line">            mx2 = ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fa) &#123;</span><br><span class="line">        ans += <span class="built_in">max</span>(<span class="number">0</span>,h[x] - mx1);</span><br><span class="line">        mx1 = <span class="built_in">max</span>(mx1,h[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> ans += <span class="built_in">max</span>(<span class="number">0</span>,h[x] - mx1) + <span class="built_in">max</span>(<span class="number">0</span>,h[x] - mx2);</span><br><span class="line">    <span class="keyword">return</span> mx1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        v[x].<span class="built_in">pb</span>(y);</span><br><span class="line">        v[y].<span class="built_in">pb</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mx = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(h[i] &gt; mx) &#123;</span><br><span class="line">            mx = h[i];</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(pos,<span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>Werewolves</title>
    <url>/2022-03-04-Werewolves.html</url>
    <content><![CDATA[#
<center>
Werewolves
</center>
<span id="more"></span>
<p>链接：<a href="https://vjudge.net/contest/482141#problem/C">传送门</a></p>
<h2 id="题目描述">题目描述</h2>
<p>给定一个树，每个节点有一个颜色，询问有多少个连通块满足主要颜色的数量严格大于<span class="math inline">$num \over 2$</span>？</p>
<h2 id="范围">范围</h2>
<p><span class="math inline"><em>n</em> ≤ 3000</span></p>
<h2 id="思路">思路</h2>
<p>比较显然的事情就是可以枚举每个颜色，判断当前颜色有多少个，最后再加和即可。</p>
<p>对于每个当前颜色设为1，其他颜色设为-1，只需要计算连通块权值大于0的个数即可。</p>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="type">int</span> res;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="type">int</span> L[N];</span><br><span class="line"><span class="type">int</span> R[N];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> tmp[N][N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa,<span class="type">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= (res &lt;&lt; <span class="number">1</span>);i ++) &#123;</span><br><span class="line">        f[x][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ret ;</span><br><span class="line">    <span class="keyword">if</span>(c[x] != col) ret = res - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> ret = res + <span class="number">1</span>;</span><br><span class="line">    L[x] = <span class="built_in">min</span>(res,ret);</span><br><span class="line">    R[x] = <span class="built_in">max</span>(res,ret);</span><br><span class="line">    f[x][ret] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y : v[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x,col);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= (res &lt;&lt; <span class="number">1</span>);i ++) &#123;</span><br><span class="line">            tmp[x][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = L[y];i &lt;= R[y];i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = L[x];j &lt;= R[x];j ++) &#123;</span><br><span class="line">                <span class="type">int</span> t = i + j - res;</span><br><span class="line">                <span class="keyword">if</span>(t &gt;= <span class="number">0</span> <span class="keyword">and</span> t &lt;= (res &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line">                    tmp[x][t] += f[y][i] * f[x][j];</span><br><span class="line">                    tmp[x][t] %= mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        L[x] = <span class="built_in">max</span>(<span class="number">0ll</span>,L[x] + L[y] - res);</span><br><span class="line">        R[x] = <span class="built_in">min</span>((res &lt;&lt; <span class="number">1</span>),R[x] + R[y] - res);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= (res &lt;&lt; <span class="number">1</span>);i ++) &#123;</span><br><span class="line">            f[x][i] += tmp[x][i];</span><br><span class="line">            f[x][i] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = res + <span class="number">1</span>;i &lt;= (res &lt;&lt; <span class="number">1</span>);i ++) &#123;</span><br><span class="line">        ans += f[x][i];</span><br><span class="line">        ans %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++) &#123;</span><br><span class="line">        cin &gt;&gt; c[i];</span><br><span class="line">        ++cnt[c[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        v[x].<span class="built_in">pb</span>(y);</span><br><span class="line">        v[y].<span class="built_in">pb</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n; k ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[k] &lt;= <span class="number">1</span>) ans += cnt[k];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res = cnt[k];</span><br><span class="line">            <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>dp</category>
        <category>树形dp</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
        <tag>SEERC</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙的约会</title>
    <url>/2022-03-01-%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A.html</url>
    <content><![CDATA[#
<center>
青蛙的约会
</center>
<span id="more"></span>
<p>链接：<a href="https://ac.nowcoder.com/acm/contest/21094/A">传送门</a></p>
<h2 id="题目描述">题目描述：</h2>
<p>给定两只青蛙的地点和速度，求相遇时间，追及问题。</p>
<h2 id="思路">思路：</h2>
<p><span class="math display">$$
x + mk = y + nk (mod \; L) \\
$$</span></p>
<p>求解最小<span class="math inline"><em>k</em></span></p>
<h2 id="代码">代码：</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x,y,m,n,L;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>,y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">exgcd</span>(b,a % b,x,y);</span><br><span class="line">        <span class="type">int</span> t = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = t - (a / b) * y;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y &gt;&gt; m &gt;&gt; n &gt;&gt; L;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">abs</span>(m - n);</span><br><span class="line">    <span class="type">int</span> b = L;</span><br><span class="line">    <span class="type">int</span> c = m &gt; n ? y - x : x - y;</span><br><span class="line">    <span class="type">int</span> p,q;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(a,b,p,q);</span><br><span class="line">    <span class="keyword">if</span>(c % d) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p = p * c / d;</span><br><span class="line">        <span class="type">int</span> t = b / d;</span><br><span class="line">        p = (p % t + t) % t;</span><br><span class="line">        cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ACM</category>
        <category>Math Theory</category>
        <category>Exgcd</category>
      </categories>
      <tags>
        <tag>Exgcd</tag>
      </tags>
  </entry>
</search>
